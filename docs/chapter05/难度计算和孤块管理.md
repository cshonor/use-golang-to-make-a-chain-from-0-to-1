# 难度计算和孤块管理

> 第五章子文档：难度计算和孤块管理详解

---

## 5.14.5 计算下一个区块的难度

**难度计算是 PoW 链的核心机制，用于自动调节挖矿难度，保证出块速度稳定。**

### 为什么需要难度调整？

**目标：**
- 比特币：平均每 10 分钟出 1 块
- 比原链：平均每 2.5 分钟出 1 块
- 不管算力怎么变，必须维持这个速度

**问题：**
- 矿工变多 → 算力变大 → 出块变快
- 矿机关机 → 算力变小 → 出块变慢

**解决方案：**
- 出块太快了 → 难度调高，更难挖
- 出块太慢了 → 难度调低，更好挖

### 难度是怎么计算的？

**1. 每隔一段区块，系统重新算一次难度**

**比特币：** 每 2016 块重新算一次难度

**节点会看：**
- 过去 2016 块实际用了多久？
- 如果实际用时比预期短 → 出块太快 → 难度调高
- 如果实际用时比预期长 → 出块太慢 → 难度调低

**2. 核心公式（超级简单）**

```
新难度 = 旧难度 × (预期时间 / 实际时间)
```

**举个超级简单例子：**
- 预期 2016 块要 14 天
- 结果大家算力太强，7 天就挖完了
- 那：
  ```
  新难度 = 旧难度 × (14天 / 7天)
         = 旧难度 × 2
  ```
- → 难度直接翻倍，更难挖

**3. 难度最终变成什么？**

- 难度 → 转换成一个叫 `bits` 的值
- 决定了：哈希前面要几个 0
- 难度越大，要求前面 0 越多
- 越难算出合法 nonce

**代码中的体现：**
```go
b.Bits == parent.CalcNextBits()
```

`CalcNextBits()` 就是在算下一个区块的难度。

**关键理解：**
- 难度计算是写死在协议里的公式
- 所有节点都按同一个公式算，保证全网难度一致
- 保证出块速度永远稳定在固定时间

---

## 5.14.6 孤块管理（Orphan Block Management）

**孤块管理是处理那些合法但暂时找不到父区块的区块的机制。**

### 什么是孤块？

**孤块（Orphan Block）的定义：**
- 合法、验证通过
- 但没被主链选中
- 被抛弃的区块

**关键理解：**
- 孤块不是"没爹"，而是"爹还在路上，先到了儿子"
- 因为网络同步的先后顺序导致的

### 孤块为什么会找不到父区块？

**这不是说区块本身有问题，而是网络同步的先后顺序导致的。**

**举个例子：**
```
矿工 A 在高度 100 的区块上，挖出了高度 101 的区块 A1。
矿工 B 几乎同时，也在高度 100 的区块上，挖出了高度 101 的区块 B1。

你的节点先收到了 B1，但此时：
- 你本地链的最高块还是 99
- 高度 100 的区块还没同步到本地

当你处理 B1 时，发现：
- 它的父哈希指向的是高度 100 的区块
- 但你本地根本没有这个区块

→ 这时，B1 就成了孤块，因为它"爹还没到"
```

**所以：**
- 孤块产生：因为网络延迟，儿子（区块）比爹（父区块）先到节点，暂时"没爹"
- 不是区块本身有问题，而是同步顺序问题

### 孤块管理是怎么管的？

**孤块管理就 3 步：**

**1. 收到区块，先找爸爸**
- 看区块里的父哈希
- 本地链里找不到这个爸爸
- → 先放进**孤块池**存着

**2. 等爸爸到了，再认儿子**
- 后来同步到了爸爸区块
- 再把孤块从池子里拿出来，接上去

**3. 接上去后，和主链比一比**
- 如果孤块所在链更长 → 切换主链
- 如果更短 → 丢掉，变成废块
- → 矿工没奖励

### 孤块是一段链吗？

**你说得非常对：孤块池里存的，其实可以是一整条侧链，而不仅仅是单个块。**

**1. 孤块是怎么变成一段链的？**

```
节点先收到 B1（高度 101），爹（高度 100）还没到 → B1 进孤块池。

紧接着，又收到了 B2（高度 102），它的父哈希是 B1 的哈希。

节点处理 B2 时，发现爹 B1 在孤块池里，于是把 B2 也挂到 B1 后面。

→ 这时，孤块池里就有了一条侧链：B1 → B2
```

**2. 什么时候会触发比较和链重组？**

```
当高度 100 的区块（也就是它们共同的爹）终于同步到本地后：

1. 孤块管理器会把 B1 和 B2 从池里取出来，尝试接入本地链

2. 接入后，它会比较：
   - 这条侧链（B1→B2，高度 102）
   - 当前主链（比如高度 101）

3. 如果侧链更长、工作量更大：
   - 节点就会触发链重组
   - 抛弃原来的主链
   - 切换到这条侧链作为新的主链
```

### 孤块管理的定时清理机制

**代码里的 `orphanExpire` 函数：**
- 用一个 goroutine 每 3 分钟执行一次清理
- 清理规则：删除 60 分钟之前加入孤块池、且一直没有父区块的"超时孤块"

**目的：**
- 防止大量无用孤块长期占用内存，导致节点性能下降
- 过滤恶意节点构造的、永远找不到父区块的恶意区块

**为什么不会把有用的孤块洗掉？**

**有用的孤块：**
- 指那些父区块很快就会同步到节点，最终能接上主链的区块
- 这类孤块的父区块，通常在几分钟内就会被同步到本地
- 一旦父区块到了，孤块管理器会立刻把它从孤块池里取出来，接入主链
- 根本等不到超时（60 分钟）

**被清洗掉的，都是"注定没用"的孤块：**
- 清洗的条件是：60 分钟内都没等到父区块
- 正常网络下，区块同步延迟远小于 60 分钟
- 如果一个孤块等了 60 分钟还没等到爹，说明：
  - 它的父区块可能已经被主链抛弃，永远不会来了
  - 或者它本身就是恶意节点构造的"假区块"
- 这类孤块，就算不洗，也永远上不了链，留着只会浪费资源

**万一真的有"有用的孤块"被洗掉了怎么办？**
- 这种情况概率极低，就算发生了，也有补救机制：
- 当节点后续同步到父区块时，会重新向全网请求这个孤块
- 其他节点如果有这个区块，会再次广播给它
- 它会再次被加入孤块池，重新等待接入主链

**总结：**
- 清洗是"丢垃圾"，不是"丢宝贝"
- 真正有用的孤块，早就被接去主链了
- 被洗掉的，都是本来就没用的垃圾

---

## 5.14.10 OrphanManager 和 OrphanBlock 结构体详解

**比原链用两个 Go 结构体来管理孤块，我帮你把源码级细节讲透：**

### 1. OrphanBlock 结构体（单个孤儿块）

**作用：** 存单个孤儿块 + 过期时间

**Go 代码结构：**
```go
type OrphanBlock struct {
    // 区块本身
    Block *types.Block

    // 过期时间（expire time）
    ExpireAt time.Time
}
```

**字段说明：**
- `Block`：指向区块的指针，存的是孤儿块本身
- `ExpireAt`：过期时间，用于超时清理

### 2. OrphanManager 结构体（孤儿块管理器）

**作用：** 管理所有孤儿块，用指针（prev hash）做索引

**Go 代码结构：**
```go
type OrphanManager struct {
    // 锁（并发安全）
    mutex sync.Mutex

    // key: 本区块hash
    // value: OrphanBlock（包含block + 过期时间）
    blocks map[Hash]*OrphanBlock

    // key: 父区块hash（指针 prev pointer）
    // value: 子区块hash列表
    children map[Hash][]Hash
}
```

**字段说明：**

| 字段 | 类型 | 作用 |
|------|------|------|
| `mutex` | `sync.Mutex` | 并发锁，保证线程安全 |
| `blocks` | `map[Hash]*OrphanBlock` | 用区块哈希作为 key，找到对应的孤儿块 |
| `children` | `map[Hash][]Hash` | 用父区块哈希作为 key，找到所有子孤儿块列表 |

**关键理解：**
- **指针（parent pointer）**：用 `PreviousBlockHash` 做索引，放在 `children` 这个 map 里，用来找父块、连链条
- **过期时间（expire time）**：存在 `OrphanBlock.ExpireAt`，用来超时清理孤儿块

### 3. Go 语言 map 语法说明

**你问的 `map[Hash]*OrphanBlock` 是什么意思？**

**Go 语言 map 的固定写法：**
```go
map[KeyType]ValueType
```

**拆开看：**
- `[ ]` **中括号里面**：写 key 的类型
  - `[Hash]` → key 是区块哈希
- **中括号后面**：写 value 的类型
  - `*OrphanBlock` → value 是指向 OrphanBlock 的指针

**完整意思：**
```go
blocks map[Hash]*OrphanBlock
```
- `blocks` 是一个 map
- key 是 `Hash`（区块哈希）
- value 是 `*OrphanBlock`（孤儿块的指针）
- 也就是：用一个哈希，找到对应的那个孤儿块

**第二个 map：**
```go
children map[Hash][]Hash
```
- `[Hash]` → key 是父区块哈希
- `[]Hash` → value 是哈希切片（一堆子区块哈希）
- 意思：给我一个父区块哈希，我能找到所有它的子孤儿块

**超级精简记忆：**
- Go 语言 map 长这样：`map[键类型]值类型`
- `map[Hash]*OrphanBlock`：key 是哈希，value 是孤儿块指针
- `map[Hash][]Hash`：key 是父哈希，value 是子哈希列表

### 4. OrphanManager 的核心方法

**所有孤儿块的管理、新增、删除、查找、清理，全部都是通过 OrphanManager 的方法来做的。**

**Go 语言结构体方法的写法：**

**格式：**
```go
func (接收者 结构体类型) 方法名(参数) 返回值 {
    // 方法体
}
```

**示例：添加孤儿块的方法**
```go
// 给 OrphanManager 加方法
func (m *OrphanManager) AddOrphanBlock(block *Block) {
    // 这里面就能用 m.blocks、m.children
    m.blocks[block.Hash()] = &OrphanBlock{
        Block:    block,
        ExpireAt: time.Now().Add(10 * time.Minute),
    }
}
```

**重点：**
- `(m *OrphanManager)` 就是接收者
- 有了它，这个函数就属于这个结构体了
- 里面可以直接用：`m.blocks`、`m.children`

**清理过期的方法：**
```go
func (m *OrphanManager) ProcessExpired() {
    now := time.Now()

    for hash, orphan := range m.blocks {
        if now.After(orphan.ExpireAt) {
            delete(m.blocks, hash)
        }
    }
}
```

**其他核心方法：**
```go
// 删除孤儿块
func (m *OrphanManager) DeleteOrphanBlock(hash Hash)

// 获取孤儿块
func (m *OrphanManager) GetOrphanBlock(hash Hash) *OrphanBlock

// 尝试把孤儿块接上链
func (m *OrphanManager) ProcessOrphanBlock(block *Block) bool
```

**使用方式：**
```go
// 先创建 manager
manager := &OrphanManager{
    blocks:   make(map[Hash]*OrphanBlock),
    children: make(map[Hash][]Hash),
}

// 调用它的方法
manager.AddOrphanBlock(block)
manager.ProcessExpired()
```

### 5. 两个结构体的关系

**OrphanBlock：**
- 只是一个数据结构
- 存：区块、过期时间
- 它自己不管理任何东西

**OrphanManager：**
- 是管理者/控制器
- 里面有那两个 map：`blocks` 和 `children`
- 所有操作都是它的方法

**最终总结：**
- `OrphanBlock` = 数据
- `OrphanManager` = 管理员 + 两个 map 索引
- 区块管理 = 调用 `OrphanManager` 的方法

### 链重组（Chain Reorganization）示例

**场景演示：**

```
时刻 T1：
主链：... → 99 → 100（高度 100）
你的节点收到 B1（高度 101），但高度 100 还没到
→ B1 进孤块池

时刻 T2：
你的节点收到 B2（高度 102），父哈希是 B1
→ B2 也进孤块池，挂在 B1 后面
孤块池：B1 → B2（高度 102）

时刻 T3：
高度 100 的区块终于同步到本地
→ 孤块管理器把 B1、B2 从池里取出，尝试接入

时刻 T4：
比较：
- 主链：高度 100
- 侧链：高度 102（B1 → B2）

侧链更长 → 触发链重组
→ 抛弃原来的主链
→ 切换到 B1 → B2 作为新主链
```

**关键理解：**
- 孤块成链：如果后续区块不断在这个孤块上延伸，孤块池里就会形成一条侧链
- 链重组：当爹到了，这条侧链被接上后，如果它比主链更长、工作量更大，就会取而代之成为新主链

---

**返回**: [区块打包和验证](./区块打包和验证.md)


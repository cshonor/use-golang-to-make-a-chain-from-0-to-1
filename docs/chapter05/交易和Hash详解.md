# 交易和 Hash 详解

> 第五章子文档：交易（Tx）和 Hash 类型详解

---

## 5.4 交易（Tx）详解

### 5.4.1 Tx 的本质

**Tx 是 Transaction（交易）的缩写，是一个自定义的结构体，用来表示一笔区块链交易。**

**核心理解：**
- ✅ **一个 Tx = 一笔交易**
- ✅ `Transactions []*Tx` 是一个**指针数组**，每个指针指向一笔交易
- ✅ 每个 `*Tx` 指向内存中一个具体的交易结构体 `Tx` 实例

### 5.4.2 Tx 结构体定义

**在比原链中的核心字段：**

```go
type Tx struct {
    Version    uint64      // 交易版本
    Inputs     []*TxInput  // 交易输入（资金来源）
    Outputs    []*TxOutput // 交易输出（资金去向）
    LockTime   uint64      // 锁定时间
    // ... 其他字段
}

type TxInput struct {
    // 引用之前的交易输出
    // 签名等信息
}

type TxOutput struct {
    Amount         uint64  // 金额
    Asset          *Asset  // 资产类型
    ControlProgram []byte  // 控制脚本（地址相关）
}
```

**字段说明：**

| 字段 | 作用 |
|------|------|
| `Version` | 交易版本号 |
| `Inputs` | 交易输入列表，指定资金来源（引用之前的交易输出） |
| `Outputs` | 交易输出列表，指定资金去向（接收方地址和金额） |
| `LockTime` | 锁定时间，交易生效的时间 |

### 5.4.3 Transactions 字段的本质

**`Transactions []*Tx` 的本质：**

- `[]*Tx`：一个**切片（slice）**，里面的每个元素都是一个指针 `*Tx`
- 每个指针 `*Tx` 指向内存中一个具体的交易结构体 `Tx` 实例
- 这个切片本身是一个**"指针数组"**，它并不直接存储交易数据，而是存储了指向多笔交易的地址

**设计优势：**
- ✅ **节省内存**：传递和存储时，只需要传递指针（8 字节），而不是整个交易结构体
- ✅ **提高效率**：修改交易时，只需要修改指针指向的内容，不需要复制整个结构体
- ✅ **灵活扩展**：切片可以动态增长，方便打包不同数量的交易

**使用示例：**
```go
// 遍历区块中的所有交易
for _, tx := range block.Transactions {
    // tx 是一个 *Tx 指针，指向一笔交易
    txHash := calculateTxHash(tx)
    fmt.Printf("交易哈希: %x\n", txHash)
}
```

**关键理解：**
- Transactions 是一个"交易指针列表"
- 每一个 `*Tx` 就是一笔交易的"入口"
- 遍历这个列表，就能拿到区块里的所有交易

---

## 5.5 Hash 类型详解

### 5.5.1 Hash 的本质

**Hash 是一个自定义类型，它的本质是一个固定长度的字节数组，用来存储 SHA256 哈希值。**

**定义：**
```go
const HashSize = 32

type Hash [HashSize]byte
```

**本质：**
- `[32]byte`：一个长度为 32 字节的数组，刚好能存下一个 SHA256 哈希值

**作用：**
- 作为区块的唯一标识（`Block.ID`）
- 作为"哈希指针"（`BlockHeader.PreviousBlockId`）
- 作为默克尔树的节点（`BlockHeader.TransactionsRoot`）

**注意：**
- `*Hash` 是指向这个哈希数组的**指针**，是为了节省内存和传递效率

### 5.5.2 交易哈希的计算

**交易哈希是交易的唯一标识，计算方式：**

```go
// 伪代码
txBytes := serializeTx(tx)        // 序列化交易
firstHash := sha256.Sum256(txBytes)  // 第一次 SHA256
txHash := sha256.Sum256(firstHash[:]) // 第二次 SHA256
```

**结果：**
- 这个结果就是 `Hash` 类型的交易 ID
- 用于唯一标识一笔交易

**计算过程详解：**

1. **序列化交易结构体**
   - 把 `Tx` 结构体里的所有字段（如发送方、接收方、金额、签名、时间戳等）
   - 按照固定的编码规则（如 RLP、Protobuf 或 JSON）转换成一个二进制字节流
   - 这个过程是为了把复杂的结构体变成一段可以被哈希函数处理的连续数据

2. **对序列化后的数据进行哈希运算**
   - 使用加密哈希函数（如 SHA-256）对这个字节流进行计算
   - 得到一个固定长度的哈希值
   - 在很多区块链（如比特币、以太坊）中，会进行**两次 SHA-256 哈希**（即 `SHA256(SHA256(data))`），以增强安全性

3. **得到交易哈希**
   - 最终得到的哈希值，就是这笔交易的唯一标识，也就是我们常说的交易 ID（TxID）

**在比原链中的使用：**
- 这些交易哈希值，就是默克尔树的叶子节点
- 最终生成 `transactionsRoot` 并写入区块头

---

**返回**: [区块与区块链详解](./区块与区块链详解.md)


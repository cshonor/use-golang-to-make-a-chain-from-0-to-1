# processBlock 流程详解

> 第五章子文档：processBlock 完整流程详解

---

## 5.14.9 processBlock 完整流程详解

**`processBlock()` 是区块上链的核心函数，我帮你把 6 个步骤拆解清楚：**

### 流程总览

```
收到区块 block
    ↓
1. 检查区块是否已存在（去重检查）
    ↓
2. 检查父区块是否存在（孤块处理）
    ↓
3. 验证并保存区块到本地链
    ↓
4. 处理孤块池（递归上链）
    ↓
5. 判断是主链延长还是侧链新增
    ↓
6. 判断是否触发链重组
```

### 步骤 1：检查区块是否已存在

**目的：** 避免重复处理同一个区块

**检查内容：**
- 计算区块哈希
- 去本地链和孤块池里查
- 如果已经存在，直接丢弃

**对应代码逻辑：**
```go
if c.BlockExist(&blockHash) {
    return c.orphanManage.BlockExist(&blockHash), nil
}
```

### 步骤 2：检查父区块是否存在

**目的：** 判断是正常区块还是孤块

**检查内容：**
- 根据区块里的 `PreviousBlockHash`，去本地链里找父区块
- 如果找不到父区块，说明"儿子先到，爹还没到"

**处理方式：**
- 如果父区块存在 → 继续下一步
- 如果父区块不存在 → 把它放进孤块池，返回

**对应代码逻辑：**
```go
if parent := c.index.GetNode(&block.PreviousBlockHash); parent == nil {
    c.orphanManage.Add(block)
    return true, nil
}
```

### 步骤 3：验证并保存区块到本地链

**目的：** 确保区块合法，然后保存

**验证内容：**
- 区块头验证（版本号、高度、难度、父哈希、时间等）
- 交易验证（签名、余额、格式等）
- 共识验证（PoW、Nonce、Bits 等）
- 全局状态验证（执行结果、状态变化等）

**处理方式：**
- 验证通过 → 保存到本地链
- 验证失败 → 拒绝区块，返回错误

**对应代码逻辑：**
```go
if err := c.saveBlock(block); err != nil {
    return false, err
}
```

**核心验证函数：** `ValidateBlockHeader()`

### 步骤 4：处理孤块池

**目的：** 把等待父区块的孤块接上链

**处理逻辑：**
- 新块上链后，去孤块池里找所有以它为父的孤块
- 把这些孤块依次上链，直到没有可上链的孤块为止
- 递归处理，可能形成一整条侧链

**对应代码逻辑：**
```go
bestBlock := c.saveSubBlock(block)
```

**关键理解：**
- 孤块池里可以存一整条侧链
- 当父区块到了，整条侧链都会被接上

### 步骤 5：判断是主链延长还是侧链新增

**目的：** 确定新块在主链上还是在侧链上

**判断逻辑：**
- 如果新块的父区块就是当前主链的最高块（`bestNode`）
  - → 说明是主链直接延长
- 否则
  - → 说明这个块被加到了侧链上

**对应代码逻辑：**
```go
if bestNode.Parent == c.bestNode {
    return false, c.connectBlock(bestBlock)
}
```

### 步骤 6：判断是否触发链重组

**目的：** 如果侧链更强，就切换主链

**判断条件：**
- 侧链的高度 > 主链高度
- 且侧链的工作量（WorkSum）>= 主链工作量

**处理方式：**
- 如果满足条件 → 触发链重组，切换到这条侧链作为新的主链
- 否则 → 区块作为侧链存在，不改变主链

**对应代码逻辑：**
```go
if bestNode.Height > c.bestNode.Height && 
   bestNode.WorkSum.Cmp(c.bestNode.WorkSum) >= 0 {
    return false, c.reorganizeChain(bestNode)
}
```

### 核心验证逻辑（ValidateBlockHeader）

**在步骤 3 中，区块头验证是最关键的一环，它检查：**

| 检查项 | 验证内容 |
|--------|---------|
| 版本号 | `b.Version >= parent.Version` |
| 区块高度 | `b.Height == parent.Height + 1` |
| 难度值 | `b.Bits == parent.CalcNextBits()` |
| 父区块哈希 | `parent.Hash == *b.PreviousBlockId` |
| 区块时间 | 时间戳是否合理 |
| 工作量证明 | Nonce 和 Bits 是否满足难度要求 |

**只要有一项不通过，区块就会被直接拒绝。**

### 比原链的验证逻辑

**代码位置：** `protocol/block.go`

**核心函数：** `processBlock()` 是核心处理入口

**验证流程：**

```
1. 检查区块是否已被处理（去重检查）
   ↓
   计算区块哈希，若本地链或孤块池已存在，则丢弃
   ↓
2. 检查父区块是否存在（父区块检查）
   ↓
   根据 PreviousBlockHash 查找父区块
   若不存在则将其标记为孤块（orphan block），存入孤块池
   ↓
3. 验证与保存（区块头验证、交易验证）
   ↓
   若父区块存在，验证交易和元数据
   通过后保存区块到本地数据库
   ↓
4. 孤块处理
   ↓
   检查孤块池，将可上链的孤块依次上链
   得到当前最高块 bestNode
   ↓
5. 主链追加或链重组
   ↓
   若 bestNode 的父区块是原主链最高块，则追加到主链
   若 bestNode 在侧链，且其高度和工作量超过主链，则触发链重组
   ↓
6. 更新本地最佳区块
```

**关键理解：**
- 如果父区块不存在，区块会被标记为**孤块（orphan block）**，存入孤块池
- 孤块需要等待父区块到达后才能被处理
- 如果侧链比主链更长，会触发链重组（reorganization）
- 孤块池里可以形成一整条侧链，而不仅仅是单个块

### 一句话总结整个流程

**`processBlock` 就是区块链的"守门员"：**
1. 先检查区块是不是重复的、是不是没爹的
2. 然后验证它是不是合法的
3. 合法就上链，再看看有没有孤块能一起接上
4. 最后判断这条新链是不是比主链更强，强就换主链

---

**返回**: [区块打包和验证](./区块打包和验证.md)


# 区块基础结构

> 第五章子文档：区块基础结构详解

---

## 5.1 区块链的本质

### 5.1.1 基本定义

**区块链是由包含交易信息的区块按时间顺序连接而成的链表式数据结构。**

**核心特点：**
- ✅ 每个区块通过一个**哈希指针**（前一个区块头的 SHA256 哈希值）指向前一个区块
- ✅ 以此保证链的完整性和不可篡改性
- ✅ 形成一条不可篡改的数据链

### 5.1.2 与普通链表的区别

| 特性 | 普通链表 | 区块链 |
|------|---------|--------|
| **指针类型** | 内存地址指针 | 哈希指针（SHA256 哈希值） |
| **存储内容** | 下一个节点的内存地址 | 前一个区块头的 SHA256 哈希值 |
| **查找方式** | 直接通过地址跳转访问 | 通过哈希值作为索引在数据库中查找 |
| **核心作用** | 遍历、连接节点 | 防篡改、验证数据完整性 |
| **依赖关系** | 依赖物理内存位置 | 不依赖物理位置，分布式兼容 |

**关键理解：**
- 普通链表指针：指向物理位置，用于遍历
- 区块链哈希指针：指向前一个区块的**数字指纹**，用于验证和防篡改

---

## 5.2 区块的核心构成

### 5.2.1 区块的两大部分

区块是区块链中数据存储的最小单元，由两部分组成：

#### 1. 区块头（BlockHeader）

**作用**：记录区块的元数据，相当于账本的"扉页"，包含交易概括信息。

**包含内容：**
- 区块链的连接信息：前一个区块的哈希值
- 挖矿信息：时间戳、随机数、难度目标
- 区块交易信息：交易默克尔树根哈希

#### 2. 区块体（Body）

**作用**：包含打包的所有交易记录，相当于账本里的"转账记录"。

**包含内容：**
- 交易列表（Transactions）：区块中所有交易的完整数据

### 5.2.2 区块的数据结构定义

**在比原链的实现中，区块（Block）的 Go 语言结构体定义：**

```go
type Block struct {
    *BlockHeader  // 区块头指针
    ID            Hash  // 区块ID，唯一标识
    Transactions  []*Tx // 交易记录列表
}
```

**结构说明：**

| 字段 | 变量名 | 数据类型 | 字节数 | 说明 |
|------|--------|---------|--------|------|
| `*BlockHeader` | BlockHeader（匿名字段） | `*BlockHeader` | 变长 | 区块头，存储元数据 |
| `ID` | ID | `Hash` | 32 | 区块 ID，当前区块的唯一标识 |
| `Transactions` | Transactions | `[]*Tx` | 变长 | 交易记录列表（指针数组） |

**关键理解：**
- `*BlockHeader`：是一个**指针**，指向区块头结构体
- `ID`：是 `Hash` 类型（32 字节的 SHA256 哈希值）
- `Transactions`：是一个**指针数组**（切片），每个元素 `*Tx` 指向一笔交易

---

## 5.3 区块头（BlockHeader）详解

### 5.3.1 区块头的构成

区块头主要由三大部分组成：

#### 1. 区块链的连接信息

- **PreviousBlockId**：前一个区块的哈希值，用于将区块与前一个区块相连
- **Height**：区块高度，记录当前区块与创世区块的距离

#### 2. 挖矿信息

- **Timestamp**：时间戳，记录区块产生的 Unix 时间戳
- **Nonce**：随机数，工作量证明（PoW）中的计数器
- **Bits**：难度目标，控制出块时间

#### 3. 区块交易信息

- **TransactionsRoot**：交易默克尔树的根哈希，用于高效验证交易完整性
- **TransactionStatusHash**：交易状态默克尔树的根哈希

### 5.3.2 区块头的结构体定义

```go
type BlockHeader struct {
    Version              uint64
    Height               uint64
    PreviousBlockId      *Hash
    Timestamp            uint64
    TransactionsRoot     *Hash
    TransactionStatusHash *Hash
    Nonce                uint64
    Bits                 uint64
    TransactionStatus    *TransactionStatus
}
```

**字段说明：**

| 字段 | 变量名 | 数据类型 | 说明 |
|------|--------|---------|------|
| `Version` | Version | `uint64` | 区块版本号，用于协议升级 |
| `Height` | Height | `uint64` | 区块高度，与创世区块的距离 |
| `PreviousBlockId` | PreviousBlockId | `*Hash` | 父区块的哈希值（哈希指针） |
| `Timestamp` | Timestamp | `uint64` | Unix 时间戳（精确到秒） |
| `TransactionsRoot` | TransactionsRoot | `*Hash` | 交易默克尔树根哈希 |
| `TransactionStatusHash` | TransactionStatusHash | `*Hash` | 交易状态默克尔树根哈希 |
| `Nonce` | Nonce | `uint64` | 工作量证明计数器（挖矿用） |
| `Bits` | Bits | `uint64` | 挖矿难度目标（难度编码值） |
| `TransactionStatus` | TransactionStatus | `*TransactionStatus` | 交易状态 |

### 5.3.3 区块 ID 的计算

**区块 ID 的来源：**
- 对整个 `BlockHeader` 进行**两次 SHA256** 哈希计算得到
- 这个哈希值就是 `Block.ID` 字段的值

**计算过程：**
```go
// 伪代码
headerBytes := serializeBlockHeader(blockHeader)
firstHash := sha256.Sum256(headerBytes)
blockID := sha256.Sum256(firstHash[:])
```

**作用：**
- 作为区块的唯一标识符，用于在数据库中索引和查找区块
- 作为"哈希指针"，被下一个区块的 `PreviousBlockId` 引用，从而形成区块链

---

## 5.4 区块的三个核心字段详解

### 5.4.1 *BlockHeader（区块头）

**变量名：** BlockHeader（匿名字段，Go 自动用类型名作为变量名）

**数据类型：** `*BlockHeader`，是一个指向 `BlockHeader` 结构体的指针

**作用：**
- 存储区块的元数据，是整个区块的"身份信息"和"连接信息"
- 嵌入了整个区块头，让 `Block` 结构体可以直接访问 `BlockHeader` 里的所有字段

**包含内容：**
- Version：区块版本号
- Height：区块高度
- PreviousBlockId：父区块哈希（链起来的关键）
- Timestamp：时间戳
- TransactionsRoot：交易默克尔树根
- Nonce / Bits：挖矿相关的随机数和难度

**意义：**
- 区块头的哈希值就是整个区块的唯一标识（ID）
- 任何对区块的篡改都会导致这个哈希值变化

### 5.4.2 ID（区块 ID）

**变量名：** ID

**数据类型：** `Hash`（这是一个自定义类型，本质上是一个长度为 32 字节的数组 `[32]byte`，用来存储 SHA256 哈希值）

**来源：**
- 对整个 `BlockHeader` 进行**两次 SHA256** 哈希计算得到

**作用：**
- 作为区块的唯一标识符，用于在数据库中索引和查找区块
- 作为"哈希指针"，被下一个区块的 `PreviousBlockId` 引用，从而形成区块链

### 5.4.3 Transactions（交易列表）

**变量名：** Transactions

**数据类型：** `[]*Tx`，是一个切片，里面的每个元素都是指向 `Tx`（交易）结构体的指针

**本质：**
- 一个**指针数组**（切片），它并不直接存储交易数据
- 而是存储了指向多笔交易的地址
- 每个 `*Tx` 指向内存中一个具体的交易结构体 `Tx` 实例

**作用：**
- 存储这个区块打包的所有交易记录，是区块体的核心内容

**意义：**
- 这些交易的哈希值会被用来构建默克尔树
- 其根哈希存储在 `TransactionsRoot` 字段中
- 这样可以高效地验证区块中任意一笔交易的完整性，而无需下载整个区块

### 5.4.4 三者关系总结

- **`*BlockHeader`** 是区块的"骨架"，定义了区块的身份和连接关系
- **`ID`** 是这个骨架的"指纹"，用来唯一标识和查找区块
- **`Transactions`** 是区块的"血肉"，承载了区块链上的核心业务数据

**验证区块时的流程：**
```
1. 用 ID 去数据库找到区块
   ↓
2. 对 BlockHeader 重新哈希，验证是否等于 ID，确保区块头未被篡改
   ↓
3. 用 TransactionsRoot 验证交易列表的完整性
```

---

## 5.5 哈希指针与区块查找

### 5.5.1 哈希指针的本质

**哈希指针存的是什么？**

- 哈希指针存的是**前一个区块头的 SHA256 哈希值**
- 它指向的是前一个区块的**"数字指纹"**，而不是它的物理位置

**为什么用哈希而不是内存地址？**

1. **防篡改**：
   - 如果有人修改了前一个区块里的任何数据，哪怕是一个字节
   - 它的区块头哈希值就会完全改变
   - 当前区块里存的"前一个区块哈希"就对不上了
   - 整个链条就会断裂，篡改行为立刻暴露

2. **去中心验证**：
   - 在分布式网络中，每个节点都有自己的一份账本副本
   - 用哈希值而不是内存地址，就不需要关心数据存在哪个节点的哪块内存里
   - 只需要通过哈希值就能验证数据的完整性和顺序

### 5.5.2 区块查找机制

**哈希指针本身不直接用来找区块，而是用来验证和确认区块的身份。**

#### 查找方式一：本地节点的键值数据库

**数据库结构：**
- **键（Key）**：区块的哈希值（即区块 ID）
- **值（Value）**：序列化后的完整区块数据

**查找流程：**
```
1. 有一个哈希值（比如从当前区块的 PrevBlockHash 字段中得到）
   ↓
2. 用这个哈希值作为键，去本地数据库中查询
   ↓
3. 如果找到对应的值，就反序列化得到完整的区块数据
   ↓
4. 对这个区块的头做一次哈希，验证它是否和你手里的哈希值一致
   ↓
5. 确保数据未被篡改
```

**代码示例：**
```go
// 伪代码示例
data, err := db.Get(prevHash, nil)
if err != nil {
    // 如果本地没有，就向P2P网络发起请求
    return requestBlockFromNetwork(prevHash)
}

// 反序列化区块
block := deserializeBlock(data)

// 验证区块哈希
calculatedHash := calculateBlockHash(block.BlockHeader)
if calculatedHash != prevHash {
    return errors.New("区块数据被篡改")
}
```

#### 查找方式二：P2P 网络中的广播与请求

**如果本地没有这个区块（比如新节点同步数据时）：**

```
1. 节点会在 P2P 网络中广播一个请求："谁有哈希为 X 的区块？"
   ↓
2. 其他拥有该区块的节点会响应，并把区块数据发送过来
   ↓
3. 收到数据后，本地节点会对区块头进行哈希计算
   ↓
4. 验证其是否等于请求的哈希值 X
   ↓
5. 验证通过后，才会将该区块存入本地数据库并加入区块链
```

### 5.5.3 为什么这样设计？

**高效查找：**
- 键值数据库对键的查询时间复杂度接近 O(1)，能快速定位到区块

**防篡改验证：**
- 通过重新计算哈希并比对，确保拿到的区块数据和"数字指纹"匹配
- 杜绝了数据被篡改的可能

**分布式兼容：**
- 不依赖于某个特定的内存地址或节点位置
- 只要哈希值正确，就能在任何地方找到并验证区块

**简单总结：**
- 哈希指针告诉你"我要找的那个区块，它的数字指纹是这个"
- 然后你拿着这个指纹，去数据库或网络里"按图索骥"，找到并验证那个区块

---

## 5.6 types 层与 bc 层的区别

### 5.6.1 核心理解

**一句话总结：**
- **types 层 = 纯粹的数据结构（区块长啥样）**
- **bc 层 = 处理区块的逻辑（区块怎么验证、怎么存、怎么跑）**

### 5.6.2 types 层（原始数据结构层）

**作用：**
- 定义了最基础的原始数据结构，比如区块、交易、输入输出等
- 专门用于在节点与节点之间进行数据传输和存储
- 是整个系统的"数据语言"

**特点：**
- ✅ 结构简单、稳定
- ✅ 不包含复杂的业务逻辑
- ✅ 只负责数据的序列化和反序列化

**包含的内容：**
- 区块头 `BlockHeader`
- 前一个哈希 `PrevHash`
- 区块 ID `Hash`
- 交易列表 `Transactions`
- **所有这些都属于 types 层！**

**types 层只干一件事：**
- 定义区块长什么样
- 就像画一张图纸：
  - 这个区块要有个头
  - 头里要存上一个区块的哈希
  - 区块要有 ID
  - 区块要装交易

**它不关心：**
- 怎么查数据库
- 怎么验证
- 怎么链起来
- 怎么同步

### 5.6.3 bc 层（虚拟机计算层）

**作用：**
- 是一个虚拟机层，专门用于执行和验证交易，提升交易验证的性能
- 处理交易的执行逻辑、状态更新和验证
- 是区块链核心业务逻辑的实现层

**特点：**
- ✅ 包含了复杂的计算和验证逻辑
- ✅ 通过优化虚拟机执行效率，来提升整个区块链的吞吐量

**bc 层干的是：**
- 拿着 types 定义好的区块，去做：
  - 验证区块对不对
  - 把区块存进数据库
  - 从数据库读区块
  - 执行交易
  - 维护整条链

### 5.6.4 两者和区块的关系

**区块的定义：**
- 在 types 层定义了区块的基础数据结构（`Block` 结构体）
- 这是区块在网络中传输和存储的格式

**区块的处理：**
- 在 bc 层，这个区块数据会被虚拟机读取、验证和执行
- 其中的交易被处理，区块链状态被更新

**简单来说：**
- types 层是"数据格式"
- bc 层是"处理引擎"
- 它们共同支撑了区块在区块链中的完整生命周期

### 5.6.5 你现在学的属于哪一层？

**你现在理解的：**
- 哈希指针
- 区块怎么链起来
- 每个区块存前一个哈希
- 区块头、区块体
- `Block` 结构体的三个字段

**全部只属于 types 层！和 bc 层半毛钱关系都没有。**

**关键理解：**
- ✅ 你现在聊的「区块链链表结构」只和 types 有关，和 bc 无关
- ✅ bc 层是后面才用到的业务逻辑，你现在根本不需要管它
- ✅ 你现在聊的东西，完全不涉及 bc 层

---

## 5.7 Go 语言结构体语法说明

### 5.7.1 标准写法

在 Go 语言里，结构体的标准写法是：

```go
type 结构体名 struct {
    变量名  数据类型
}
```

### 5.7.2 结构体字段的两种写法

#### 1. 标准字段（有变量名）

```go
type Block struct {
    ID Hash  // 变量名：ID，数据类型：Hash
}
```

#### 2. 匿名字段（嵌入）

```go
type Block struct {
    *BlockHeader  // 没有显式写变量名，Go 会自动把类型名当作变量名
}
```

**说明：**
- 这里是匿名字段（没有显式写变量名）
- Go 会自动把类型名当作变量名，所以变量名就是 `BlockHeader`
- 数据类型是 `*BlockHeader`，是一个指向 `BlockHeader` 结构体的指针
- 常用于结构体嵌入，让 `Block` 可以直接访问 `BlockHeader` 里的所有字段

### 5.7.3 指针类型

**`*类型`** 表示存储的是另一个变量的内存地址，用来间接访问数据。

**示例：**
- `*BlockHeader`：指向 `BlockHeader` 结构体的指针
- `*Hash`：指向 `Hash` 类型的指针
- `*Tx`：指向 `Tx` 结构体的指针

### 5.7.4 自定义类型

像 `Hash`、`Tx` 这些，其实都是基于基础类型（如 `[32]byte`）的别名，让代码更易读。

**示例：**
```go
type Hash [32]byte  // Hash 是 [32]byte 的别名
type Tx struct { ... }  // Tx 是自定义结构体
```

---

**返回**: [区块与区块链详解](./区块与区块链详解.md)


# 普通交易详解

> 比原链（Bytom）普通交易（用户交易）的详细说明

---

## 概述

**普通交易（用户交易）**是比原链中最常见的交易类型，由普通用户或钱包应用创建，用于转移已有资产（BTM、资产通证等）。它通过引用之前的UTXO作为输入，创建新的UTXO作为输出。

---

## 核心特征

- **发起方**：普通用户/钱包
- **作用**：转移已有资产（BTM、资产通证等）
- **特点**：有明确的输入（来源UTXO）和输出（目标地址）
- **位置**：可以在区块中的任意位置（除了第一笔）
- **验证**：需要提供签名，验证UTXO所有权

---

## 数据结构（Go语言）

### SpendInput 结构

```go
// 普通交易的Input结构（SpendInput）
type SpendInput struct {
    SpendCommitment
    Arguments [][]byte  // 见证数据（签名等）
}

// SpendCommitment包含的字段
type SpendCommitment struct {
    AssetAmount        // 资产ID和金额
    SourceID       bc.Hash    // 引用的交易ID
    SourcePosition uint64     // 引用的输出索引
    VMVersion      uint64     // 虚拟机版本
    ControlProgram []byte     // 控制脚本（地址）
    StateData      [][]byte   // 状态数据
}
```

### TxOutput 结构

```go
// 普通交易的Output结构（TxOutput）
type TxOutput struct {
    AssetVersion uint64
    OutputCommitment
    CommitmentSuffix []byte
    TypedOutput      // 输出类型（OriginalOutputType 或 VoteOutputType）
}

// OutputCommitment包含的字段
type OutputCommitment struct {
    AssetAmount      // 资产ID和金额
    VMVersion      uint64     // 虚拟机版本
    ControlProgram []byte     // 控制脚本（收款地址）
    StateData      [][]byte   // 状态数据
}

// AssetAmount结构
type AssetAmount struct {
    AssetId *bc.AssetID  // 资产ID
    Amount  uint64       // 金额（最小单位）
}
```

### 完整的普通交易示例

```go
normalTx := &Tx{
    Version: 1,
    Inputs: []*TxInput{
        {
            AssetVersion: 1,
            TypedInput: &SpendInput{
                SpendCommitment: SpendCommitment{
                    AssetAmount: bc.AssetAmount{
                        AssetId: &btmAssetID,
                        Amount:  1500000000,  // 1.5 BTM
                    },
                    SourceID:       previousTxHash,  // 引用的交易哈希
                    SourcePosition: 0,              // 引用的输出索引
                    VMVersion:      1,
                    ControlProgram: senderAddress,   // 发送者地址
                },
                Arguments: [][]byte{signature},  // 签名数据
            },
        },
    },
    Outputs: []*TxOutput{
        {
            Amount: 1000000000,  // 1.0 BTM 给收款人
            AssetID: btmAssetID,
            ControlProgram: receiverAddress,
        },
        {
            Amount: 499000000,   // 0.499 BTM 找零（1.5 - 1.0 - 0.001手续费）
            AssetID: btmAssetID,
            ControlProgram: senderAddress,
        },
    },
}
```

---

## 关键字段说明

### Input 字段

#### SourceID（引用的交易ID）
- **类型**：`bc.Hash`
- **作用**：指定要花费的UTXO来自哪一笔交易
- **示例**：`"7d769fb564e5dc4947dab944c33e1b3ec522b8c..."`

#### SourcePosition（引用的输出索引）
- **类型**：`uint64`
- **作用**：指定要花费的UTXO是交易中的第几个输出（从0开始）
- **示例**：`0` 表示第一个输出，`1` 表示第二个输出

> **详细说明**：请参考 [比原链交易类型对比](./比原链交易类型对比.md#sourceposition-详解)

#### Arguments（见证数据）
- **类型**：`[][]byte`（字节数组的数组）
- **作用**：包含签名等验证信息，用于证明有权花费该UTXO
- **内容**：通常是私钥对交易数据的签名

#### ControlProgram（控制脚本）
- **类型**：`[]byte`
- **作用**：控制脚本（地址），用于验证所有权
- **说明**：从ControlProgram可以派生出人类可读的地址

### Output 字段

#### AssetAmount（资产和金额）
- **AssetId**：资产ID（如BTM的资产ID）
- **Amount**：输出金额（最小单位，需要除以10^8得到BTM数量）

#### ControlProgram（控制脚本）
- **类型**：`[]byte`
- **作用**：控制脚本（收款地址），用于锁定输出
- **说明**：定义了花费该输出的条件

---

## 工作原理

### 1. 选择要花费的UTXO

**用户选择要花费的UTXO**（之前收到的交易输出）：
- 钱包自动选择合适的UTXO
- 选择策略：单个足够大的UTXO 或 组合多个小UTXO

### 2. 构造交易输入

**构造交易输入**，引用该UTXO（`SourceID` + `SourcePosition`）：
```go
SpendInput{
    SourceID:       utxo.TxHash,      // 引用的交易ID
    SourcePosition: utxo.OutputIndex, // 引用的输出索引
    Amount:         utxo.Amount,       // 金额
    ControlProgram: utxo.Address,     // 地址
}
```

### 3. 使用私钥签名

**使用私钥签名**，证明拥有该UTXO的所有权：
```go
signature := Sign(utxo, privateKey)
Arguments: [][]byte{signature}
```

### 4. 创建交易输出

**创建交易输出**，包括：
- **给收款人的输出**：转账金额
- **找零给自己的输出**：输入金额 - 转账金额 - 手续费

### 5. 计算手续费

**手续费** = 输入总额 - 输出总额

```go
fee := inputAmount - outputAmount - changeAmount
```

---

## Input 和 Output 的对应关系

### 核心理解

- **Input（输入）** = 花费旧的UTXO（引用之前交易的输出）
- **Output（输出）** = 创建新的UTXO（未来可以被引用）

### 关键概念澄清

#### 1. 不能用"账户余额"的思路理解

**UTXO模型 vs 账户模型：**

| 维度 | UTXO模型（比原链） | 账户模型（以太坊） |
|------|------------------|------------------|
| **余额概念** | 一堆UTXO的总和 | 账户里的一个数字 |
| **资产存储** | 独立的TxOutput片段 | 账户余额字段 |
| **转账方式** | 消耗旧UTXO，创建新UTXO | 直接修改账户余额 |

**重要理解：**
- 没有"账户余额"这个概念，只有一堆未花费的交易输出（UTXO）
- 你的"余额"其实是你能控制的所有UTXO的总和
- 每一笔交易，就是把一些旧的UTXO（作为Input）"花掉"，然后生成新的UTXO（作为Output）

#### 2. Output和Input结构为什么不一样？

**职责完全不同：**

| 结构 | 职责 | 内容 |
|------|------|------|
| **TxOutput** | 定义"这钱是谁的、怎么拿" | 资产ID、金额、控制脚本（锁定条件） |
| **TxInput** | 证明"我就是那个人、我能拿" | 引用旧Output、签名（解锁证明） |

**结构不一样的原因：**
- `Output`：代表"新产生的、未被花费的资产"，是一个承诺（Commitment）
- `Input`：代表"要花掉的、之前产生的Output"，是一个见证（Witness），包含签名、解锁脚本等

#### 3. Output如何"变成"Input？

**不是结构上的转换，而是角色上的转换：**

```
今天的Output（待花费的资产）
    ↓
被新交易的Input引用
    ↓
变成"被花费的资产来源"
    ↓
标记为已花费，不能再被引用
```

**关键点：**
- 当一个`TxOutput`被一笔新交易的`TxInput`引用时，它就从"待花费的资产"变成了"这笔交易的资金来源"
- 它不是结构上变成了`TxInput`，而是角色上变成了`TxInput`的来源
- 一旦被引用，这个旧的`TxOutput`就被标记为"已花费"，不能再被其他交易引用了

#### 4. 如何引用Output？

**不是通过内存地址，而是通过链上唯一标识：**

引用一个`TxOutput`需要两个信息：

```go
type TxInput struct {
    SourceID       bc.Hash    // 1. 交易ID（TxID）- 产生这个Output的交易哈希
    SourcePosition uint64     // 2. 输出索引（OutputIndex）- 这笔交易中第几个输出（从0开始）
    // ...
}
```

**查找过程：**
1. 节点根据`SourceID`（交易ID）找到对应的交易
2. 根据`SourcePosition`（输出索引）找到交易中的具体输出
3. 验证这个Output是否已被花费
4. 验证签名是否满足控制脚本的条件

**和内存地址的区别：**
- **内存地址**：程序运行时数据在内存中的临时位置，重启后就变了
- **TxID + OutputIndex**：数据在区块链分布式账本中的永久位置，全网唯一，永远不变

#### 5. Output和账户的关系

**Output确实和地址有关，但不是传统账户：**

- 每个`TxOutput`都有一个控制脚本（`ControlProgram`），它定义了"谁能花这笔钱"
- 这个脚本通常是一个公钥哈希，对应一个地址
- 所以我们说这个Output属于这个地址的"账户"
- **但这不是传统意义上的账户**，而是"地址控制的UTXO集合"

**全网可见性：**
- ✅ **全网都能看到**这个`TxOutput`属于哪个地址（通过控制脚本）
- ❌ **但看不到**背后的真实身份（伪匿名性）
- 任何人都可以在区块链上查到每个`TxOutput`的控制脚本（公钥哈希），从而知道它对应的地址
- 但这个地址只是一串字符，除非你自己公开关联，否则没人知道这个地址背后是谁

#### 6. Input和Output是否都在链上？

**是的，永远都在链上，永久保存！**

**Output：**
- ✅ 一旦上链，永远存在，永远不会被删除
- ✅ 即使被花费，也只是被标记为"已花费"，数据还在链上
- ✅ 交易还在、TxID还在、Output内容还在

**Input：**
- ✅ 一旦打包进区块，也永远留在链上
- ✅ Input的作用就是记录"我要花哪个Output"和"我提供签名解锁"
- ✅ 它本身也是交易的一部分，永久保存

**区块链特性：**
- 只增不减，只加不删
- 一切交易记录永久保存
- 可以追溯到创世区块的每一笔交易

#### 7. 全网资产的流转

**全网的资产 = 所有未被花费的TxOutput的总和**

```
UTXO池（所有未花费的Output）
    ↓
交易发生：Input从池子里"拿走"旧的Output
    ↓
标记旧Output为已花费
    ↓
产生新的Output，放回池子里
    ↓
循环...
```

**关键理解：**
- `TxOutput`：代表"未被花费的资产"，存在于UTXO池中
- `TxInput`：代表"被花费的资产"，它引用池子里的某个Output，把它从池子里移除
- 整个系统的资产，就是在`TxOutput`的不断"消耗-生成"中流转的

### 完整流程

```
交易A的输出（Output）
    ↓
成为UTXO（未花费交易输出）
    ↓
被交易B的输入（Input）引用
    ↓
交易B的输出（Output）
    ↓
成为新的UTXO
    ↓
循环...
```

### 实现机制详解

#### 1. 创建交易输出（Output）→ 成为UTXO

**步骤1：创建交易输出**

```go
// 创建交易输出
output := &TxOutput{
    AssetVersion: 1,
    OutputCommitment: OutputCommitment{
        AssetAmount: bc.AssetAmount{
            AssetId: &btmAssetID,
            Amount:  1000000000,  // 1.0 BTM
        },
        VMVersion:      1,
        ControlProgram: receiverAddress,  // 收款地址
        StateData:      nil,
    },
    TypedOutput: &originalTxOutput{},
}

// 将输出添加到交易
tx.Outputs = append(tx.Outputs, output)
```

**步骤2：计算输出ID（OutputID）**

每个输出都有一个唯一的ID，通过以下方式计算：

```go
// 计算输出的唯一ID
func ComputeOutputID(
    sourceID bc.Hash,      // 来源交易ID
    position uint64,       // 输出在交易中的位置
    assetAmount bc.AssetAmount,
    controlProgram []byte,
) bc.Hash {
    // 将所有这些信息组合起来，计算哈希
    data := append(sourceID.Bytes(), ...)
    data = append(data, encodeUint64(position)...)
    data = append(data, assetAmount.Bytes()...)
    data = append(data, controlProgram...)
    
    return sha256.Sum256(data)  // 返回哈希值作为OutputID
}
```

**步骤3：输出成为UTXO**

当交易被确认并写入区块后：

```go
// 交易确认后，输出成为UTXO
func ProcessTransactionOutputs(tx *Tx, blockHeight uint64) {
    for i, output := range tx.Outputs {
        outputID := tx.OutputID(i)  // 计算输出ID
        
        // 创建UTXO记录
        utxo := &UTXO{
            OutputID:    outputID,
            TxHash:      tx.ID(),
            OutputIndex: uint64(i),
            AssetID:     output.AssetAmount.AssetId,
            Amount:      output.AssetAmount.Amount,
            Address:     deriveAddress(output.ControlProgram),
            BlockHeight: blockHeight,
            Spent:       false,  // 初始状态：未花费
        }
        
        // 将UTXO添加到UTXO集合中
        utxoSet.Add(utxo)
    }
}
```

#### 2. 引用UTXO作为输入（Input）

**步骤1：查找可用的UTXO**

```go
// 用户想要花费UTXO时，需要先找到它
func FindUTXO(address string, amount uint64) []*UTXO {
    // 从UTXO集合中查找属于该地址的未花费输出
    var availableUTXOs []*UTXO
    
    for _, utxo := range utxoSet {
        if utxo.Address == address && 
           utxo.Spent == false && 
           utxo.Amount >= amount {
            availableUTXOs = append(availableUTXOs, utxo)
        }
    }
    
    return availableUTXOs
}
```

**步骤2：创建交易输入，引用UTXO**

```go
// 创建输入，引用之前的UTXO
func CreateSpendInput(utxo *UTXO, privateKey []byte) *TxInput {
    // 1. 使用私钥签名，证明拥有该UTXO
    signature := Sign(utxo, privateKey)
    
    // 2. 创建SpendInput，引用UTXO
    return &TxInput{
        AssetVersion: 1,
        TypedInput: &SpendInput{
            SpendCommitment: SpendCommitment{
                AssetAmount: bc.AssetAmount{
                    AssetId: utxo.AssetID,
                    Amount:  utxo.Amount,
                },
                SourceID:       utxo.TxHash,      // 引用交易ID
                SourcePosition: utxo.OutputIndex, // 引用输出索引
                VMVersion:      1,
                ControlProgram: utxo.Address,
            },
            Arguments: [][]byte{signature},  // 签名证明
        },
    }
}
```

**步骤3：验证UTXO引用**

当交易被验证时，系统会检查：

```go
// 验证输入引用的UTXO是否存在且未花费
func ValidateInput(input *TxInput) error {
    // 1. 从SourceID和SourcePosition计算OutputID
    outputID := ComputeOutputID(
        input.SourceID,
        input.SourcePosition,
        input.AssetAmount,
        input.ControlProgram,
    )
    
    // 2. 查找UTXO
    utxo := utxoSet.Get(outputID)
    if utxo == nil {
        return errors.New("UTXO not found")
    }
    
    // 3. 检查UTXO是否已被花费
    if utxo.Spent {
        return errors.New("UTXO already spent")
    }
    
    // 4. 验证签名
    if !VerifySignature(utxo, input.Arguments) {
        return errors.New("invalid signature")
    }
    
    return nil
}
```

#### 3. 标记UTXO为已花费

当交易被确认后，引用的UTXO会被标记为已花费：

```go
// 交易确认后，标记UTXO为已花费
func MarkUTXOAsSpent(tx *Tx) {
    for _, input := range tx.Inputs {
        if spendInput, ok := input.TypedInput.(*SpendInput); ok {
            // 计算被花费的UTXO的ID
            outputID := ComputeOutputID(
                spendInput.SourceID,
                spendInput.SourcePosition,
                spendInput.AssetAmount,
                spendInput.ControlProgram,
            )
            
            // 标记为已花费
            utxo := utxoSet.Get(outputID)
            if utxo != nil {
                utxo.Spent = true
                utxoSet.Update(utxo)
            }
        }
    }
}
```

#### 4. 完整实现示例

```go
// 完整的交易流程实现
func CreateAndProcessTransaction() {
    // ===== 第一步：创建交易A =====
    txA := &Tx{
        Version: 1,
        Inputs:  []*TxInput{...},  // 从之前的UTXO花费
        Outputs: []*TxOutput{
            {
                Amount: 1000000000,  // 1.0 BTM
                AssetID: btmAssetID,
                ControlProgram: addressA,
            },
        },
    }
    
    // 交易A被确认后，输出成为UTXO
    ProcessTransactionOutputs(txA, blockHeight)
    // 现在 addressA 有一个 1.0 BTM 的UTXO
    
    // ===== 第二步：创建交易B，引用交易A的输出 =====
    // 1. 查找可用的UTXO
    utxo := FindUTXO(addressA, 1000000000)[0]
    
    // 2. 创建输入，引用UTXO
    input := CreateSpendInput(utxo, privateKeyA)
    
    // 3. 创建新的输出
    txB := &Tx{
        Version: 1,
        Inputs: []*TxInput{input},  // 引用交易A的输出
        Outputs: []*TxOutput{
            {
                Amount: 900000000,  // 0.9 BTM 给收款人
                AssetID: btmAssetID,
                ControlProgram: addressB,
            },
            {
                Amount: 99000000,   // 0.099 BTM 找零（0.001作为手续费）
                AssetID: btmAssetID,
                ControlProgram: addressA,
            },
        },
    }
    
    // 4. 验证交易
    if err := ValidateTransaction(txB); err != nil {
        panic(err)
    }
    
    // 5. 交易B被确认后
    // - 标记交易A的输出为已花费
    MarkUTXOAsSpent(txB)
    // - 交易B的输出成为新的UTXO
    ProcessTransactionOutputs(txB, blockHeight+1)
    // 现在 addressB 有一个 0.9 BTM 的UTXO
    // addressA 有一个 0.099 BTM 的UTXO（找零）
}
```

### 关键数据结构

```go
// UTXO结构
type UTXO struct {
    OutputID    bc.Hash    // 输出的唯一ID
    TxHash      bc.Hash    // 创建该输出的交易ID
    OutputIndex uint64     // 输出在交易中的位置
    AssetID     bc.AssetID // 资产ID
    Amount      uint64     // 金额
    Address     string     // 地址
    BlockHeight uint64     // 创建时的区块高度
    Spent       bool       // 是否已被花费
}

// UTXO集合（用于快速查找）
type UTXOSet struct {
    utxos map[bc.Hash]*UTXO  // 以OutputID为key
}
```

### 关键要点

1. **OutputID的计算**：通过交易ID、输出位置、资产信息等计算唯一ID
2. **UTXO的存储**：使用OutputID作为key，存储在UTXO集合中
3. **引用的方式**：通过SourceID（交易ID）+ SourcePosition（输出索引）定位UTXO
4. **验证机制**：检查UTXO存在性、是否已花费、签名有效性
5. **状态更新**：交易确认后，标记旧UTXO为已花费，新输出成为新UTXO

### 示例

```
交易1 (ID: tx1)
├── Output[0] → 1.0 BTM → 地址A  ← 成为UTXO
└── Output[1] → 2.0 BTM → 地址B  ← 成为UTXO

交易2 (ID: tx2)
├── Input: 引用交易1的Output[0]  ← 花费UTXO
└── Output[0] → 0.9 BTM → 地址C  ← 创建新UTXO（0.1 BTM作为手续费）
```

---

## SourcePosition 详解

### 为什么需要 SourcePosition？

一个交易可以有**多个输出（Outputs）**，每个输出都是一个独立的UTXO。当你想要花费某个UTXO时，需要明确指定：
1. **哪个交易**（通过 `SourceID`）
2. **该交易中的第几个输出**（通过 `SourcePosition`）

### 示例说明

假设交易A（ID: `abc123...`）有3个输出：

```
交易A (SourceID: abc123...)
├── Output[0] (SourcePosition: 0) → 1.0 BTM → 地址A
├── Output[1] (SourcePosition: 1) → 2.0 BTM → 地址B  
└── Output[2] (SourcePosition: 2) → 0.5 BTM → 地址C
```

现在你想花费地址B收到的2.0 BTM，你需要：

```go
SpendInput{
    SourceID:       "abc123...",  // 交易A的ID
    SourcePosition: 1,           // 交易A的第2个输出（索引从0开始）
    Amount:        200000000,    // 2.0 BTM
    // ...
}
```

### 关键理解

- `SourcePosition` 是**数组索引**，从 **0** 开始
- `SourcePosition: 0` = 第1个输出
- `SourcePosition: 1` = 第2个输出
- `SourcePosition: 2` = 第3个输出
- 以此类推...

---

## 实际应用场景

### 创建普通交易

```go
// 用户转账时创建普通交易
func CreateTransferTx(
    fromUTXO *UTXO,      // 要花费的UTXO
    toAddress []byte,    // 收款地址
    amount uint64,       // 转账金额
    privateKey []byte,   // 私钥（用于签名）
) *Tx {
    // 计算找零
    fee := uint64(1000000)  // 假设手续费为 0.001 BTM
    change := fromUTXO.Amount - amount - fee
    
    // 创建签名
    signature := Sign(fromUTXO, privateKey)
    
    return &Tx{
        Version: 1,
        Inputs: []*TxInput{
            NewSpendInput(
                [][]byte{signature},           // Arguments
                fromUTXO.TxHash,               // SourceID
                fromUTXO.AssetID,              // AssetID
                fromUTXO.Amount,               // Amount
                fromUTXO.OutputIndex,          // SourcePosition
                fromUTXO.ControlProgram,       // ControlProgram
                nil,                           // StateData
            ),
        },
        Outputs: []*TxOutput{
            NewOriginalTxOutput(fromUTXO.AssetID, amount, toAddress, nil),
            NewOriginalTxOutput(fromUTXO.AssetID, change, fromUTXO.Address, nil),
        },
    }
}
```

### 使用场景

- **用户之间转账BTM或其他资产**
  - 通过钱包应用创建交易
  - 需要用户签名授权
  - 需要支付手续费

- **UTXO选择策略**
  - 选择单个足够大的UTXO
  - 或组合多个小UTXO

- **找零机制**
  - 如果输入总额大于输出总额，多余的部分会作为找零
  - 找零会创建一个新的UTXO，返还给发送者

---

## 手续费机制

### 手续费计算

在UTXO模型里，没有专门的 "Gas 费" 字段，手续费是这样产生的：

```
交易手续费 = ∑(所有 Input 的金额) - ∑(所有 Output 的金额)
```

### 手续费示例

**假设你要给朋友转 1.0 BTM，你钱包里有一个 1.5 BTM 的 UTXO：**

```
Input（输入）：
- 你提供这个 1.5 BTM 的 UTXO 作为交易输入

Output（输出）：
- Output 1：创建一个新的 UTXO，金额 1.0 BTM，地址是你朋友的
- Output 2：创建另一个新的 UTXO，金额 0.49 BTM，地址是你自己的（这就是找零）

手续费：
1.5 - 1.0 - 0.49 = 0.01 BTM
这 0.01 BTM 就作为手续费给了矿工
```

---

## 在区块浏览器中识别

### 识别方法

1. **查看交易的 `Inputs` 数组**
   - 普通交易至少有一个输入

2. **检查Input类型**
   ```go
   if tx.Inputs[0].InputType() == SpendInputType {
       // 这是普通交易
   }
   ```

3. **查看输入引用**
   - `Inputs` 中的每个输入都有 `SourceID` 和 `SourcePosition`
   - 有 `spent_output_id` 字段（在JSON中）

4. **查看签名数据**
   - 有 `Arguments` 字段（包含签名数据）
   - 在JSON中显示为 `witness_arguments`

5. **交易位置**
   - 可以在区块中的任意位置（除了第一笔）

6. **JSON格式**
   ```json
   {
     "inputs": [
       {
         "type": "spend",
         "spent_output_id": "...",
         "witness_arguments": [...]
       }
     ]
   }
   ```

---

## 实际JSON结构示例

**区块浏览器显示的简化视图：**
```
从 bm1q5wtajhqBvxvu3pedct23qcvqqww44wa 转账：
- 31798 BTM → bmiqvenshuudsjhqysxak5yeudp5evmetly9zna69
- 9999.995 BTM → bm1qvr68qcfjw6lu7euqfr9gky6g9rxgjegrsjkd8d
- 1798 BTM → ...
手续费：0.005 BTM
```

**底层实际的JSON数据结构：**
```json
{
  "id": "7d769fb564e5dc4947dab944c33e1b3ec522b8celebdaf365d00edf576fbe7c1",
  "version": 1,
  "size": 464,
  "time_range": 0,
  "status_fail": false,
  "inputs": [
    {
      "type": "spend",
      "asset_id": "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
      "asset_definition": [],
      "amount": 3179800000000,
      "address": "bm1q5wtajhqBvxvu3pedct23qcvqqww44wa",
      "control_program": "00148397d2cae03019667221cb70b514186010076876",
      "input_id": "cb299ef868d4f7de93c2dfb23b955283fc769179636f4dcfab344976056287",
      "spent_output_id": "be08e806d5fa7ba234a586fb8ed68a94c0ff79f657a1c9064db124336acbfa55",
      "witness_arguments": [
        "01a1b2c3d4e5f6...",
        "02f6e5d4c3b2a1..."
      ],
      "mux_id": "999556543fb339227585279b2b1c3a17a05bd624aa68feedda2092026280858"
    }
  ],
  "outputs": [
    {
      "type": "control",
      "id": "058c30247fa93cc30690799aa5a34f11df94m27562045094c4fd2d896125",
      "position": 0,
      "asset_id": "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
      "asset_definition": {},
      "amount": 999999500000,
      "address": "bmiqvens3huudsjhqyaxak5yeudp5evmetlyzna65",
      "control_program": "0014666708df9c6c25701206eda04cflala659bcafe4"
    }
  ]
}
```

> **详细字段解析**：请参考 [Annotated结构详解](./Annotated结构详解.md)

---

## 常见问题

### Q1: 为什么需要 SourcePosition？

**A:** 因为一个交易可能有多个输出，每个输出都是独立的UTXO。必须通过 `SourcePosition` 精确定位到具体是哪个输出。

### Q2: 手续费是如何计算的？

**A:** 手续费 = 输入总额 - 输出总额。没有专门的"手续费"字段，是通过差额自动计算的。

### Q3: 找零是如何工作的？

**A:** 如果输入总额大于你要支付的金额，多余的部分会以一个新的UTXO形式，再转回你自己的地址。

### Q4: 普通交易需要等待成熟期吗？

**A:** 不需要。普通交易的输出一旦确认立即可用，不像Coinbase交易需要等待成熟期。

---

## 相关资源

- [比原链交易类型对比](./比原链交易类型对比.md)
- [交易基础数据结构](./交易基础数据结构.md)
- [Annotated结构详解](./Annotated结构详解.md)
- [UTXO模型详解](./UTXO模型详解.md)
- [比原链技术文档](https://github.com/Bytom/bytom)

---

**返回**: [第六章目录](./README.md)


# 普通交易详解

> 比原链（Bytom）普通交易（用户交易）的详细说明

---

## 概述

**普通交易（用户交易）**是比原链中最常见的交易类型，由普通用户或钱包应用创建，用于转移已有资产（BTM、资产通证等）。它通过引用之前的UTXO作为输入，创建新的UTXO作为输出。

---

## 核心特征

- **发起方**：普通用户/钱包
- **作用**：转移已有资产（BTM、资产通证等）
- **特点**：有明确的输入（来源UTXO）和输出（目标地址）
- **位置**：可以在区块中的任意位置（除了第一笔）
- **验证**：需要提供签名，验证UTXO所有权

---

## 数据结构（Go语言）

### SpendInput 结构

```go
// 普通交易的Input结构（SpendInput）
type SpendInput struct {
    SpendCommitment
    Arguments [][]byte  // 见证数据（签名等）
}

// SpendCommitment包含的字段
type SpendCommitment struct {
    AssetAmount        // 资产ID和金额
    SourceID       bc.Hash    // 引用的交易ID
    SourcePosition uint64     // 引用的输出索引
    VMVersion      uint64     // 虚拟机版本
    ControlProgram []byte     // 控制脚本（地址）
    StateData      [][]byte   // 状态数据
}
```

### TxOutput 结构

```go
// 普通交易的Output结构（TxOutput）
type TxOutput struct {
    AssetVersion uint64
    OutputCommitment
    CommitmentSuffix []byte
    TypedOutput      // 输出类型（OriginalOutputType 或 VoteOutputType）
}

// OutputCommitment包含的字段
type OutputCommitment struct {
    AssetAmount      // 资产ID和金额
    VMVersion      uint64     // 虚拟机版本
    ControlProgram []byte     // 控制脚本（收款地址）
    StateData      [][]byte   // 状态数据
}

// AssetAmount结构
type AssetAmount struct {
    AssetId *bc.AssetID  // 资产ID
    Amount  uint64       // 金额（最小单位）
}
```

### 完整的普通交易示例

```go
normalTx := &Tx{
    Version: 1,
    Inputs: []*TxInput{
        {
            AssetVersion: 1,
            TypedInput: &SpendInput{
                SpendCommitment: SpendCommitment{
                    AssetAmount: bc.AssetAmount{
                        AssetId: &btmAssetID,
                        Amount:  1500000000,  // 1.5 BTM
                    },
                    SourceID:       previousTxHash,  // 引用的交易哈希
                    SourcePosition: 0,              // 引用的输出索引
                    VMVersion:      1,
                    ControlProgram: senderAddress,   // 发送者地址
                },
                Arguments: [][]byte{signature},  // 签名数据
            },
        },
    },
    Outputs: []*TxOutput{
        {
            Amount: 1000000000,  // 1.0 BTM 给收款人
            AssetID: btmAssetID,
            ControlProgram: receiverAddress,
        },
        {
            Amount: 499000000,   // 0.499 BTM 找零（1.5 - 1.0 - 0.001手续费）
            AssetID: btmAssetID,
            ControlProgram: senderAddress,
        },
    },
}
```

---

## 关键字段说明

### Input 字段

#### SourceID（引用的交易ID）
- **类型**：`bc.Hash`
- **作用**：指定要花费的UTXO来自哪一笔交易
- **示例**：`"7d769fb564e5dc4947dab944c33e1b3ec522b8c..."`

#### SourcePosition（引用的输出索引）
- **类型**：`uint64`
- **作用**：指定要花费的UTXO是交易中的第几个输出（从0开始）
- **示例**：`0` 表示第一个输出，`1` 表示第二个输出

> **详细说明**：请参考 [比原链交易类型对比](./比原链交易类型对比.md#sourceposition-详解)

#### Arguments（见证数据）
- **类型**：`[][]byte`（字节数组的数组）
- **作用**：包含签名等验证信息，用于证明有权花费该UTXO
- **内容**：通常是私钥对交易数据的签名

#### ControlProgram（控制脚本）
- **类型**：`[]byte`
- **作用**：控制脚本（地址），用于验证所有权
- **说明**：从ControlProgram可以派生出人类可读的地址

### Output 字段

#### AssetAmount（资产和金额）
- **AssetId**：资产ID（如BTM的资产ID）
- **Amount**：输出金额（最小单位，需要除以10^8得到BTM数量）

#### ControlProgram（控制脚本）
- **类型**：`[]byte`
- **作用**：控制脚本（收款地址），用于锁定输出
- **说明**：定义了花费该输出的条件

---

## 工作原理

### 1. 选择要花费的UTXO

**用户选择要花费的UTXO**（之前收到的交易输出）：
- 钱包自动选择合适的UTXO
- 选择策略：单个足够大的UTXO 或 组合多个小UTXO

### 2. 构造交易输入

**构造交易输入**，引用该UTXO（`SourceID` + `SourcePosition`）：
```go
SpendInput{
    SourceID:       utxo.TxHash,      // 引用的交易ID
    SourcePosition: utxo.OutputIndex, // 引用的输出索引
    Amount:         utxo.Amount,       // 金额
    ControlProgram: utxo.Address,     // 地址
}
```

### 3. 使用私钥签名

**使用私钥签名**，证明拥有该UTXO的所有权：
```go
signature := Sign(utxo, privateKey)
Arguments: [][]byte{signature}
```

### 4. 创建交易输出

**创建交易输出**，包括：
- **给收款人的输出**：转账金额
- **找零给自己的输出**：输入金额 - 转账金额 - 手续费

### 5. 计算手续费

**手续费** = 输入总额 - 输出总额

```go
fee := inputAmount - outputAmount - changeAmount
```

---

## Input 和 Output 的对应关系

### 核心理解

- **Input（输入）** = 花费旧的UTXO（引用之前交易的输出）
- **Output（输出）** = 创建新的UTXO（未来可以被引用）

### 完整流程

```
交易A的输出（Output）
    ↓
成为UTXO（未花费交易输出）
    ↓
被交易B的输入（Input）引用
    ↓
交易B的输出（Output）
    ↓
成为新的UTXO
    ↓
循环...
```

### 示例

```
交易1 (ID: tx1)
├── Output[0] → 1.0 BTM → 地址A  ← 成为UTXO
└── Output[1] → 2.0 BTM → 地址B  ← 成为UTXO

交易2 (ID: tx2)
├── Input: 引用交易1的Output[0]  ← 花费UTXO
└── Output[0] → 0.9 BTM → 地址C  ← 创建新UTXO（0.1 BTM作为手续费）
```

---

## SourcePosition 详解

### 为什么需要 SourcePosition？

一个交易可以有**多个输出（Outputs）**，每个输出都是一个独立的UTXO。当你想要花费某个UTXO时，需要明确指定：
1. **哪个交易**（通过 `SourceID`）
2. **该交易中的第几个输出**（通过 `SourcePosition`）

### 示例说明

假设交易A（ID: `abc123...`）有3个输出：

```
交易A (SourceID: abc123...)
├── Output[0] (SourcePosition: 0) → 1.0 BTM → 地址A
├── Output[1] (SourcePosition: 1) → 2.0 BTM → 地址B  
└── Output[2] (SourcePosition: 2) → 0.5 BTM → 地址C
```

现在你想花费地址B收到的2.0 BTM，你需要：

```go
SpendInput{
    SourceID:       "abc123...",  // 交易A的ID
    SourcePosition: 1,           // 交易A的第2个输出（索引从0开始）
    Amount:        200000000,    // 2.0 BTM
    // ...
}
```

### 关键理解

- `SourcePosition` 是**数组索引**，从 **0** 开始
- `SourcePosition: 0` = 第1个输出
- `SourcePosition: 1` = 第2个输出
- `SourcePosition: 2` = 第3个输出
- 以此类推...

---

## 实际应用场景

### 创建普通交易

```go
// 用户转账时创建普通交易
func CreateTransferTx(
    fromUTXO *UTXO,      // 要花费的UTXO
    toAddress []byte,    // 收款地址
    amount uint64,       // 转账金额
    privateKey []byte,   // 私钥（用于签名）
) *Tx {
    // 计算找零
    fee := uint64(1000000)  // 假设手续费为 0.001 BTM
    change := fromUTXO.Amount - amount - fee
    
    // 创建签名
    signature := Sign(fromUTXO, privateKey)
    
    return &Tx{
        Version: 1,
        Inputs: []*TxInput{
            NewSpendInput(
                [][]byte{signature},           // Arguments
                fromUTXO.TxHash,               // SourceID
                fromUTXO.AssetID,              // AssetID
                fromUTXO.Amount,               // Amount
                fromUTXO.OutputIndex,          // SourcePosition
                fromUTXO.ControlProgram,       // ControlProgram
                nil,                           // StateData
            ),
        },
        Outputs: []*TxOutput{
            NewOriginalTxOutput(fromUTXO.AssetID, amount, toAddress, nil),
            NewOriginalTxOutput(fromUTXO.AssetID, change, fromUTXO.Address, nil),
        },
    }
}
```

### 使用场景

- **用户之间转账BTM或其他资产**
  - 通过钱包应用创建交易
  - 需要用户签名授权
  - 需要支付手续费

- **UTXO选择策略**
  - 选择单个足够大的UTXO
  - 或组合多个小UTXO

- **找零机制**
  - 如果输入总额大于输出总额，多余的部分会作为找零
  - 找零会创建一个新的UTXO，返还给发送者

---

## 手续费机制

### 手续费计算

在UTXO模型里，没有专门的 "Gas 费" 字段，手续费是这样产生的：

```
交易手续费 = ∑(所有 Input 的金额) - ∑(所有 Output 的金额)
```

### 手续费示例

**假设你要给朋友转 1.0 BTM，你钱包里有一个 1.5 BTM 的 UTXO：**

```
Input（输入）：
- 你提供这个 1.5 BTM 的 UTXO 作为交易输入

Output（输出）：
- Output 1：创建一个新的 UTXO，金额 1.0 BTM，地址是你朋友的
- Output 2：创建另一个新的 UTXO，金额 0.49 BTM，地址是你自己的（这就是找零）

手续费：
1.5 - 1.0 - 0.49 = 0.01 BTM
这 0.01 BTM 就作为手续费给了矿工
```

---

## 在区块浏览器中识别

### 识别方法

1. **查看交易的 `Inputs` 数组**
   - 普通交易至少有一个输入

2. **检查Input类型**
   ```go
   if tx.Inputs[0].InputType() == SpendInputType {
       // 这是普通交易
   }
   ```

3. **查看输入引用**
   - `Inputs` 中的每个输入都有 `SourceID` 和 `SourcePosition`
   - 有 `spent_output_id` 字段（在JSON中）

4. **查看签名数据**
   - 有 `Arguments` 字段（包含签名数据）
   - 在JSON中显示为 `witness_arguments`

5. **交易位置**
   - 可以在区块中的任意位置（除了第一笔）

6. **JSON格式**
   ```json
   {
     "inputs": [
       {
         "type": "spend",
         "spent_output_id": "...",
         "witness_arguments": [...]
       }
     ]
   }
   ```

---

## 实际JSON结构示例

**区块浏览器显示的简化视图：**
```
从 bm1q5wtajhqBvxvu3pedct23qcvqqww44wa 转账：
- 31798 BTM → bmiqvenshuudsjhqysxak5yeudp5evmetly9zna69
- 9999.995 BTM → bm1qvr68qcfjw6lu7euqfr9gky6g9rxgjegrsjkd8d
- 1798 BTM → ...
手续费：0.005 BTM
```

**底层实际的JSON数据结构：**
```json
{
  "id": "7d769fb564e5dc4947dab944c33e1b3ec522b8celebdaf365d00edf576fbe7c1",
  "version": 1,
  "size": 464,
  "time_range": 0,
  "status_fail": false,
  "inputs": [
    {
      "type": "spend",
      "asset_id": "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
      "asset_definition": [],
      "amount": 3179800000000,
      "address": "bm1q5wtajhqBvxvu3pedct23qcvqqww44wa",
      "control_program": "00148397d2cae03019667221cb70b514186010076876",
      "input_id": "cb299ef868d4f7de93c2dfb23b955283fc769179636f4dcfab344976056287",
      "spent_output_id": "be08e806d5fa7ba234a586fb8ed68a94c0ff79f657a1c9064db124336acbfa55",
      "witness_arguments": [
        "01a1b2c3d4e5f6...",
        "02f6e5d4c3b2a1..."
      ],
      "mux_id": "999556543fb339227585279b2b1c3a17a05bd624aa68feedda2092026280858"
    }
  ],
  "outputs": [
    {
      "type": "control",
      "id": "058c30247fa93cc30690799aa5a34f11df94m27562045094c4fd2d896125",
      "position": 0,
      "asset_id": "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
      "asset_definition": {},
      "amount": 999999500000,
      "address": "bmiqvens3huudsjhqyaxak5yeudp5evmetlyzna65",
      "control_program": "0014666708df9c6c25701206eda04cflala659bcafe4"
    }
  ]
}
```

> **详细字段解析**：请参考 [Annotated结构详解](./Annotated结构详解.md)

---

## 常见问题

### Q1: 为什么需要 SourcePosition？

**A:** 因为一个交易可能有多个输出，每个输出都是独立的UTXO。必须通过 `SourcePosition` 精确定位到具体是哪个输出。

### Q2: 手续费是如何计算的？

**A:** 手续费 = 输入总额 - 输出总额。没有专门的"手续费"字段，是通过差额自动计算的。

### Q3: 找零是如何工作的？

**A:** 如果输入总额大于你要支付的金额，多余的部分会以一个新的UTXO形式，再转回你自己的地址。

### Q4: 普通交易需要等待成熟期吗？

**A:** 不需要。普通交易的输出一旦确认立即可用，不像Coinbase交易需要等待成熟期。

---

## 相关资源

- [比原链交易类型对比](./比原链交易类型对比.md)
- [交易基础数据结构](./交易基础数据结构.md)
- [Annotated结构详解](./Annotated结构详解.md)
- [UTXO模型详解](./UTXO模型详解.md)
- [比原链技术文档](https://github.com/Bytom/bytom)

---

**返回**: [第六章目录](./README.md)


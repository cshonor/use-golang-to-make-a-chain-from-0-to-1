# 第一章：公链设计架构 - 学习笔记

## 📅 学习日期
- 开始日期：YYYY-MM-DD
- 完成日期：YYYY-MM-DD

## 📚 核心概念

### 比原链整体架构（7层架构）

比原链采用分层架构设计，从用户交互到运行环境共分为7层：

```
用户交互层
    ↓
接口层
    ↓
内核层
    ↓
钱包层
    ↓
共识层
    ↓
数据存储层
    ↓
P2P分布式网络层
    ↓
运行环境
```

---

### 1. 用户交互层（User Interaction Layer）

用户交互层是用户与比原链系统交互的入口，提供两种交互方式。

#### 1.1 bytomcli 客户端

**定义：**
- `bytomcli` 是一个 RPC 客户端
- 通过命令行建立用户与 `bytomd` 进程之间的通信

**功能：**
- 在部署了比原链的机器上，用户可以使用 `bytomcli` 可执行文件
- 发起各种对比原链的管理请求
- 发送请求后，由 `bytomd` 进程接收并处理

**工作流程：**
```
用户 → bytomcli → RPC请求 → bytomd进程 → 处理请求
```

**生命周期：**
- `bytomcli` 发送请求后，其完整生命周期结束
- 后续处理由 `bytomd` 进程完成

**特点：**
- 命令行交互方式
- 适合开发者和高级用户
- 轻量级，资源占用少

#### 1.2 bytom-dashboard

**定义：**
- `bytom-dashboard` 是比原链的 Web 图形界面

**功能：**
- 与 `bytomcli` 功能相似，都是发送请求并与 `bytomd` 进程建立通信
- 通过 Web 页面与 `bytomd` 进程交互
- 提供更友好的交互体验

**部署：**
- 在部署比原链的机器上，`bytom-dashboard` 功能默认启用
- 无需手动部署

**配置：**
- 用户可以通过传递参数来决定是否启用或禁用该功能
- 示例：传递 `--web.closed` 参数可以禁用该功能

**特点：**
- Web 页面交互方式
- 适合普通用户
- 图形化界面，操作更直观
- 默认启用，可通过参数关闭

**源码地址：**
- GitHub: https://github.com/Bytom/bytom-dashboard

#### 1.3 两种工具对比

| 特性 | bytomcli | bytom-dashboard |
|------|----------|-----------------|
| 交互方式 | 命令行 | Web 页面 |
| 用户群体 | 开发者、高级用户 | 普通用户 |
| 部署方式 | 独立可执行文件 | 默认集成在 bytomd 中 |
| 资源占用 | 轻量级 | 相对较重 |
| 使用场景 | 脚本自动化、调试 | 日常操作、可视化 |

**连接关系：**
- 两者都通过接口层（API Server）与 `bytomd` 进程交互
- 都使用 RPC 协议进行通信

---

### 2. 接口层（Interface Layer）

接口层是比原链架构中的关键组件，主要负责接收、处理和响应来自用户和矿池的请求。

#### 2.1 API Server 概述

**定义：**
- API Server 是比原链架构中的关键组件
- 主要服务于 `bytomcli` 和 `dashboard`
- 负责接收、处理和响应用户及矿池的请求

**默认配置：**
- 默认监听端口：`9888`
- 可通过配置文件修改端口

#### 2.2 API Server 架构

API Server 内部采用三层结构处理请求：

```
┌─────────────────────┐
│   http server       │  ← 接收 HTTP 请求
└─────────────────────┘
         ↓
┌─────────────────────┐
│   mux router        │  ← 路由匹配
└─────────────────────┘
         ↓
┌─────────────────────┐
│   handler           │  ← 处理业务逻辑
└─────────────────────┘
```

**三层组件说明：**

1. **http server**
   - HTTP 服务器，负责监听和接收请求
   - 监听指定地址，等待客户端连接

2. **mux router**
   - 路由管理器，负责路由匹配
   - 根据请求的 URL 路径和方法匹配对应的路由

3. **handler**
   - 请求处理器，负责处理具体的业务逻辑
   - 每个路由对应一个 handler 回调函数

#### 2.3 API Server 主要功能

1. **接收和处理请求**
   - 接收来自 `bytomcli` 或 `bytom-dashboard` 的请求
   - 处理用户和矿池的各种操作请求

2. **交易管理接口**
   - 交易打包（packaging）
   - 交易签名（signing）
   - 交易提交（submission）

3. **本地钱包接口管理**
   - 钱包相关操作
   - 账户管理
   - 资产管理

4. **本地 P2P 节点信息接口**
   - 节点信息查询
   - 网络状态查询

5. **本地矿工挖矿操作接口**
   - 挖矿相关操作
   - 矿工管理

#### 2.4 请求处理流程

API Server 处理请求的完整流程：

```
1. 接收请求（Reception）
   ↓
   API Server 在运行过程中监听指定地址
   接收来自 bytomcli 或 bytom-dashboard 的请求
   
2. 创建 Goroutine（Goroutine Creation）
   ↓
   为每个请求创建一个新的 goroutine
   实现并发处理，提高性能
   
3. 解析请求（Parsing）
   ↓
   读取并解析请求内容
   提取请求参数、请求体等信息
   
4. 路由匹配（Route Matching）
   ↓
   将解析后的请求匹配到对应的路由项
   根据 URL 路径、HTTP 方法等进行匹配
   
5. 调用 Handler（Handler Invocation）
   ↓
   调用匹配路由项对应的 Handler 回调函数
   执行具体的业务逻辑处理
   
6. 返回响应（Response）
   ↓
   Handler 处理完成后
   API Server 将响应发送回 bytomcli 或 bytom-dashboard
```

**关键特性：**
- **并发处理**：每个请求使用独立的 goroutine，支持高并发
- **路由匹配**：灵活的路由机制，支持 RESTful API 设计
- **统一接口**：为不同的客户端提供统一的接口

#### 2.5 连接关系

- `API Server` → 内核层的 `交易管理`（处理交易相关请求）
- `handler` → 内核层的 `智能合约`（处理智能合约相关请求）
- `API Server` → 钱包层（处理钱包相关请求）
- `API Server` → P2P 网络层（处理节点信息请求）

#### 2.6 实现要点

**技术要点：**
- HTTP 服务器搭建（使用 Go 标准库 `net/http`）
- 路由管理（使用 `mux` 或类似的路由库）
- 请求处理器（handler）设计
- 并发处理（goroutine 的使用）
- 请求解析和响应构建

**设计要点：**
- RESTful API 设计规范
- 错误处理和异常管理
- 请求验证和参数校验
- 日志记录和监控

---

### 3. 内核层（Core Layer）- 核心层

#### 3.1 内核层概述

**重要性：**
- 内核层是比原链中最重要的功能层
- 约占代码总量的 **54%**
- 包含区块链的核心逻辑和关键功能

**核心组成部分：**
1. **区块和交易管理**（Block and Transaction Management）
2. **智能合约**（Smart Contract）
3. **虚拟机**（Virtual Machine）

**基础结构：**
- 区块链的基本结构是链表（Linked List）
- 由一个个区块（Block）组成
- 每个区块链包含成千上万个区块
- 每个区块包含一个或多个交易（Transaction）

**核心功能：**
- 管理区块和交易
- 执行智能合约
- 验证区块和交易
- 处理孤块和分叉

---

#### 3.2 内核层模块架构

内核层包含以下核心模块：

```
┌─────────────────────────────────────────────────┐
│              内核层（Kernel Layer）              │
├─────────────────────────────────────────────────┤
│  交易管理          │  BUTXO  │  交易池  │  孤块管理 │
│  build/sign/submit │         │          │          │
├─────────────────────────────────────────────────┤
│  智能合约          │  交易验证 │  区块验证 │  数据存储 │
│  BVM/Equity        │          │          │          │
└─────────────────────────────────────────────────┘
```

---

#### 3.3 交易管理（Transaction Management）

**子组件：**
- `build` - 构建交易
- `sign` - 签名交易
- `submit` - 提交交易

**功能：**
- 交易的完整生命周期管理
- 交易构建、签名、提交流程

**连接关系：**
- → 钱包层的 `密钥管理`（签名需要私钥）

---

#### 3.4 BUTXO（Bytom UTXO）

**功能：**
- 比原链的 UTXO 模型实现
- 管理未花费的交易输出（Unspent Transaction Output）
- 跟踪所有可用的 UTXO

**作用：**
- 支持交易的输入输出管理
- 防止双花攻击
- 维护账户余额

---

#### 3.5 交易池（Transaction Pool）

**功能：**
- 存储待确认的交易
- 等待被打包进区块的交易管理
- 维护待处理交易的队列

**工作流程：**
1. 节点接收到新交易
2. 验证交易合法性
3. 验证通过后放入交易池
4. 等待矿工打包

**重要性：**
- 是交易从提交到上链的中间环节
- 管理待处理的交易队列
- 支持交易的优先级排序

---

#### 3.6 孤块管理（Orphan Block Management）

**功能：**
- 管理父区块尚未被验证的区块
- 处理分叉情况下的区块管理
- 临时存储孤块，等待父区块

**处理流程：**
当节点接收到新区块时：
1. 验证新区块的有效性
2. **如果新区块的父区块不在现有主链中**：
   - 进入孤块管理
   - 等待父区块的到来
3. **如果父区块在主链中**：
   - 将新区块添加到主链
   - 更新区块链状态

**重要性：**
- 处理网络延迟导致的区块乱序
- 处理分叉情况
- 确保区块链的一致性

---

#### 3.7 智能合约（Smart Contract）

**定义：**
- 传统意义上的合约是现实生活中的协议
- 在区块链中，智能合约是一种计算机协议
- 旨在以数字化的方式，更便捷地促进、验证或执行合约的协商或履行
- 智能合约本质上是运行在虚拟机上的**程序代码**

**核心特性：**
1. **可追踪性**（Traceability）：所有合约执行过程都可以被追踪
2. **不可逆转性**（Irreversibility）：合约一旦执行，结果不可逆转

**重要性：**
- 智能合约是比原链中**最核心和最重要的部分**
- 使得无需第三方信任机构即可进行可信交易

**子组件：**
- `BVM` - Bytom Virtual Machine（比原链虚拟机）
- `Equity` - 资产/权益管理

**功能：**
- 智能合约的执行环境
- 资产发行和管理
- 合约代码的执行
- 实现去中心化的可信交易

**后续章节内容：**
- 智能合约模型（主流模型：UTXO 模型、账户模型）
- 运行原理
- BVM 虚拟机的工作机制
- 区块链上的智能合约如何实现无需第三方信任机构的可信交易

**连接关系：**
- → 钱包层的 `资产管理`

---

#### 3.8 虚拟机（Virtual Machine）- BVM

**定义：**
- BVM（Bytom Virtual Machine）是比原链虚拟机
- 是建立在区块链上的代码执行环境

**主要功能：**
- 处理比原链系统中的智能合约
- 执行智能合约代码
- 提供安全的执行环境

**重要性：**
- BVM 是比原链中非常重要的部分
- 在智能合约的存储、执行和验证过程中起着关键作用

**编程语言：**
- BVM 的智能合约使用 **Equity 语言**编写
- Equity 是比原链专门为智能合约设计的编程语言

**网络运行：**
- 比原链是一个点对点（P2P）网络
- 每个节点都运行 BVM
- 所有节点执行相同的指令
- 确保网络的一致性和去中心化

**执行环境：**
- BVM 运行在**沙箱环境**中
- 与主区块链完全隔离
- 确保智能合约执行的安全性
- 防止恶意代码影响主链

**特点：**
- **隔离性**：沙箱环境，与主链隔离
- **一致性**：所有节点执行相同指令
- **安全性**：防止恶意代码执行
- **可验证性**：执行结果可验证

---

#### 3.8 交易验证（Transaction Validation）

**功能：**
- 验证交易的有效性
- 检查交易签名、UTXO 合法性等
- 防止无效交易进入交易池

**验证内容：**
- 交易签名验证
- UTXO 合法性验证
- 交易金额验证
- 防双花检查

**连接关系：**
- → 共识层的 `PoW` 和 `Tensority`

---

#### 3.9 区块验证（Block Validation）

**功能：**
- 验证区块的有效性
- 检查区块哈希、交易根等
- 验证区块中的交易

**验证内容：**
- 区块哈希验证
- 默克尔树根验证
- 区块中的交易验证
- 工作量证明验证

**连接关系：**
- → 共识层的 `PoW` 和 `Tensority`

---

#### 3.10 数据存储（Data Storage）

**功能：**
- 内核层的数据存储
- 临时数据或特定核心数据存储
- 缓存常用数据

---

#### 3.11 区块处理流程

当节点接收到新区块时的处理流程：

```
接收新区块
    ↓
验证区块有效性
    ↓
    ├─→ 父区块不在主链？
    │       ↓
    │   进入孤块管理
    │       ↓
    │   等待父区块
    │
    └─→ 父区块在主链？
            ↓
        添加到主链
            ↓
        更新区块链状态
```

**详细步骤：**
1. **接收新区块**：从 P2P 网络接收新区块
2. **验证区块**：验证区块的有效性（哈希、签名等）
3. **检查父区块**：
   - 如果父区块不在主链 → 进入孤块管理
   - 如果父区块在主链 → 添加到主链
4. **更新状态**：更新本地区块链状态

---

#### 3.12 交易生命周期（完整流程）

交易的完整生命周期包含 6 个步骤：

**示例场景：**
A 通过钱包向 B 发出一笔交易，交易金额为 100 比原币（BTM）

**步骤 1：发起交易**
- A 通过钱包创建交易
- 指定接收方 B 和金额 100 BTM
- 交易包含输入（UTXO）和输出

**步骤 2：广播交易**
- 交易被广播到 P2P 网络中
- 通过网络传播到所有节点

**步骤 3：验证交易**
- 矿工收到交易信息
- 验证交易合法性：
  - 签名验证
  - UTXO 验证
  - 金额验证
  - 防双花检查

**步骤 4：打包交易**
- 矿工将多个交易打包
- 组成一个新区块
- 包含区块头和交易列表

**步骤 5：加入区块链**
- 新区块加入到已经存在的区块链中
- 通过共识机制确认
- 更新区块链状态

**步骤 6：交易完成**
- 交易完成，成为区块链的一部分
- 不可篡改，永久记录
- B 可以查询到收到的 100 BTM

**完整流程图：**
```
A 发起交易
    ↓
广播到 P2P 网络
    ↓
矿工验证交易
    ↓
打包成新区块
    ↓
加入区块链
    ↓
交易完成
```

---

#### 3.13 内核层的重要性

**代码占比：**
- 内核层约占比原链代码总量的 **54%**
- 是系统中最复杂和最重要的部分

**核心职责：**
1. **区块管理**：创建、验证、存储区块
2. **交易管理**：处理交易的完整生命周期
3. **智能合约**：执行合约代码
4. **验证机制**：确保区块链的安全性和一致性

**设计原则：**
- 模块化设计，各模块职责清晰
- 高内聚低耦合
- 易于测试和维护
- 支持扩展和优化

---

### 4. 钱包层（Wallet Layer）

#### 4.1 钱包层概述

**类比理解：**
- 钱包可以类比于我们日常生活中的**保险箱**
- 我们关心保险箱的**开门方式**（密钥）和其中保存的**财产**（UTXO）

**主要职责：**
比原链钱包层主要负责：
1. **保存密钥**：安全存储私钥和公钥
2. **管理地址**：生成和管理区块链地址
3. **维护 UTXO 信息**：跟踪和管理未花费的交易输出
4. **处理交易的生成和签名**：构建交易、签名交易
5. **对外提供接口**：提供钱包和交易相关的 API 接口

---

#### 4.2 钱包层模块架构

钱包层包含 8 个核心模块：

```
┌─────────────────────────────────────────────────┐
│              钱包层（Wallet Layer）              │
├─────────────────────────────────────────────────┤
│  密钥管理  │  公钥管理  │  账户管理  │  资产管理  │
├─────────────────────────────────────────────────┤
│  地址管理  │  Token管理 │  UTXO     │  数据存储  │
└─────────────────────────────────────────────────┘
```

---

#### 4.3 钱包层模块详解

**第一行模块：**

1. **密钥管理**（Key Management）
   - 私钥的生成、存储和管理
   - 私钥的安全保护（加密存储）
   - 私钥的导入和导出

2. **公钥管理**（Public Key Management）
   - 公钥的生成（从私钥派生）
   - 公钥的存储和管理
   - 公钥的验证

3. **账户管理**（Account Management）
   - 账户的创建和管理
   - 账户信息的维护
   - 账户权限控制

4. **资产管理**（Asset Management）
   - 资产余额查询
   - 资产转账管理
   - 资产状态跟踪

**第二行模块：**

5. **地址管理**（Address Management）
   - 地址的生成（从公钥派生）
   - 地址的验证
   - 地址簿管理

6. **Token 管理**（Token Management）
   - Token 的发行和管理
   - Token 余额查询
   - Token 转账

7. **UTXO**（Unspent Transaction Output）
   - UTXO 的查询和管理
   - UTXO 的更新
   - UTXO 的选择（用于交易输入）

8. **数据存储**（Data Storage）
   - 钱包数据的持久化存储
   - 密钥、地址、UTXO 等数据的存储
   - 数据备份和恢复

---

#### 4.4 交易发送流程（三步）

比原链的交易发送分为三步：

**步骤 1：Build（构建交易）**
- **作用**：根据交易的输入和输出，构造交易数据
- **过程**：
  - 选择要使用的 UTXO（交易输入）
  - 指定接收方地址和金额（交易输出）
  - 计算交易费用
  - 构建交易结构
- **结果**：生成未签名的交易数据

**步骤 2：Sign（签名交易）**
- **作用**：使用私钥对每个交易输入进行签名
- **过程**：
  - 获取交易输入的私钥
  - 对交易数据进行哈希
  - 使用私钥对哈希值进行签名
  - 将签名附加到交易输入中
- **结果**：生成已签名的交易数据

**步骤 3：Submit（提交交易）**
- **作用**：将交易提交到网络进行广播，等待打包
- **过程**：
  - 验证交易的完整性
  - 提交到 API Server
  - 广播到 P2P 网络
  - 进入交易池等待打包
- **结果**：交易被网络接收，等待矿工打包

**完整流程图：**
```
用户发起转账请求
    ↓
步骤 1：Build（构建交易）
    - 选择 UTXO（输入）
    - 指定接收地址和金额（输出）
    - 计算交易费用
    ↓
步骤 2：Sign（签名交易）
    - 使用私钥签名每个输入
    - 生成交易签名
    ↓
步骤 3：Submit（提交交易）
    - 提交到 API Server
    - 广播到 P2P 网络
    - 进入交易池
    ↓
等待矿工打包
```

---

#### 4.5 钱包层功能总结

**核心功能：**
1. **密钥管理**：安全存储和管理私钥、公钥
2. **地址管理**：生成和管理区块链地址
3. **UTXO 管理**：跟踪和管理未花费的交易输出
4. **交易构建**：根据输入输出构建交易
5. **交易签名**：使用私钥签名交易
6. **交易提交**：提交交易到网络

**对外接口：**
- 钱包创建和管理接口
- 地址生成和查询接口
- 余额查询接口
- 交易构建接口
- 交易签名接口
- 交易提交接口

**连接关系：**
- 所有组件 → 数据存储层（持久化存储钱包数据）
- 密钥管理 → 交易签名（提供私钥）
- UTXO 管理 → 交易构建（提供输入）
- 资产管理 → 余额查询（提供余额信息）

---

### 5. 共识层（Consensus Layer）

#### 5.1 共识层概述

**核心功能：**
- 共识层用于实现**全网数据的一致性**
- 区块链是去中心化账本，需要全网对账本达成共识
- 通过验证区块和交易，保证新的区块在所有节点上以相同的方式产生

**工作原理：**
简单说，共识机制就是通过某种方式竞争"记账权"：
1. 得到记账权的节点可以将自己生成的区块追加到现有区块链的尾部
2. 其他节点可以根据相同的规则，验证并接受这些区块
3. 丢弃那些无法通过验证的区块

**重要性：**
- 共识层是区块链的核心机制
- 确保所有节点对账本状态达成一致
- 防止双重支付和网络攻击

---

#### 5.2 共识层架构

共识层包含两个核心组件：

```
┌─────────────────────────────────────┐
│        共识层（Consensus Layer）     │
├─────────────────────────────────────┤
│  PoW  │  Tensority                  │
└─────────────────────────────────────┘
```

**组件说明：**

1. **PoW（Proof-of-Work）**
   - 工作量证明共识机制
   - 通过计算能力竞争记账权
   - 需要消耗大量计算资源

2. **Tensority**
   - 比原链特有的共识算法
   - AI/ASIC 友好挖矿
   - 结合了机器学习和挖矿

---

#### 5.3 共识机制工作原理

**竞争记账权：**
- 节点通过某种方式竞争"记账权"
- 不同共识机制有不同的竞争方式：
  - PoW：通过计算能力竞争
  - PoS：通过持币量竞争
  - DPoS：通过投票选举

**区块追加：**
- 获得记账权的节点生成新区块
- 将新区块追加到现有区块链的尾部
- 更新区块链状态

**验证和接受：**
- 其他节点根据相同的规则验证新区块
- 验证通过后接受新区块
- 更新本地的区块链状态

**丢弃无效区块：**
- 无法通过验证的区块被丢弃
- 确保只有有效的区块被添加到链上
- 维护区块链的完整性和安全性

---

#### 5.4 常见共识机制

**1. PoW（Proof-of-Work，工作量证明）**
- **原理**：通过计算能力竞争记账权
- **特点**：需要消耗大量计算资源
- **代表**：比特币、以太坊（早期）
- **优势**：安全性高，去中心化程度高
- **劣势**：能耗高，出块速度慢

**2. PoS（Proof-of-Stake，股权证明）**
- **原理**：通过持币量和持币时间竞争记账权
- **特点**：不需要大量计算资源
- **代表**：以太坊 2.0、Cardano
- **优势**：能耗低，出块速度快
- **劣势**：可能产生富者愈富的问题

**3. DPoS（Delegated Proof-of-Stake，委托股权证明）**
- **原理**：通过投票选举代表节点
- **特点**：由代表节点轮流记账
- **代表**：EOS、TRON
- **优势**：出块速度快，效率高
- **劣势**：去中心化程度相对较低

**4. Tensority（比原链特有）**
- **原理**：结合机器学习和挖矿
- **特点**：AI/ASIC 友好
- **优势**：支持 AI 计算，资源利用效率高
- **应用**：比原链

---

#### 5.5 共识层的作用

**1. 实现数据一致性**
- 确保所有节点对账本状态达成一致
- 防止数据不一致和分叉

**2. 保证区块产生的一致性**
- 通过验证区块和交易
- 保证新的区块在所有节点上以相同的方式产生

**3. 防止攻击**
- 防止双重支付攻击
- 防止 51% 攻击
- 维护网络安全

**4. 确定区块顺序**
- 确定区块的有效性
- 确定区块的顺序
- 处理分叉情况

---

#### 5.6 连接关系

- → 数据存储层（存储共识相关的数据）
- ← 内核层（接收区块和交易进行验证）
- ← P2P 网络层（接收网络中的区块）

---

#### 5.7 实现要点

**技术要点：**
- PoW 挖矿算法实现
- Tensority 算法实现
- 难度调整机制
- 区块验证机制
- 分叉处理机制

**设计要点：**
- 共识算法的选择
- 难度调整策略
- 出块时间设置
- 奖励机制设计

---

### 6. 数据存储层（Data Storage Layer）

#### 6.1 数据存储层概述

**功能：**
- 比原链的数据存储层存储所有链上地址、资产交易和其他相关信息
- 提供可靠高效的数据存储服务
- 支持快速查询和数据持久化

**两层架构：**
数据存储层分为两个主要部分：

1. **缓存层（Cache）**
   - 大多数查询首先在缓存中进行
   - 减少磁盘 I/O 压力
   - 提高查询速度

2. **持久化存储层（Persistent Storage）**
   - 如果缓存中没有找到数据，则从持久化存储读取
   - 读取后将数据副本添加到缓存中
   - 确保数据不丢失

---

#### 6.2 数据存储层架构

```
┌─────────────────────────────────────┐
│            cache（缓存层）           │
└─────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────┐
│        数据存储层（接口层）            │
└─────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────┐
│            Level DB                  │
│  ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐│
│  │acces │ │ core │ │discov│ │trust ││
│  │token │ │      │ │er    │ │hist  ││
│  └──────┘ └──────┘ └──────┘ └──────┘│
│  ┌──────┐ ┌──────┐ ┌──────┐        │
│  │txdb  │ │txfeed│ │wallet│        │
│  └──────┘ └──────┘ └──────┘        │
└─────────────────────────────────────┘
```

---

#### 6.3 LevelDB 数据库

**定义：**
- LevelDB 是比原链默认使用的持久化存储数据库
- 由 Google 开发的高效键值数据库
- 基于 LSM-Tree（Log-Structured Merge Tree）结构

**特点：**
- **高效**：读写性能优秀
- **单进程服务**：LevelDB 是单进程服务
- **并发限制**：多个进程不能同时读写同一个数据库
- **键值存储**：基于键值对的存储模型

**使用限制：**
- 同一时间只能有一个进程访问数据库
- 或者一个进程的多个并发读写操作
- 不支持多进程并发访问

---

#### 6.4 数据库文件详解

比原链使用 7 个独立的数据库文件（`.db` 文件）：

**1. accesstoken.db**
- **内容**：存储令牌信息
- **具体用途**：钱包访问控制权限
- **作用**：管理钱包的访问令牌和权限控制

**2. core.db**
- **内容**：存储核心数据库
- **具体用途**：主链相关数据
  - 区块信息（Block Information）
  - 交易信息（Transaction Information）
  - 资产信息（Asset Information）
- **作用**：存储区块链的核心数据

**3. discover.db**
- **内容**：存储分布式网络中的端到端节点信息
- **具体用途**：P2P 网络节点发现相关数据
- **作用**：维护网络中的节点信息

**4. trusthistory.db**
- **内容**：存储分布式网络中的恶意节点信息
- **具体用途**：记录不信任的节点历史
- **作用**：防止恶意节点攻击，维护网络安全

**5. txdb.db**
- **内容**：交易数据库
- **具体用途**：存储交易相关数据
- **作用**：管理交易的存储和查询

**6. txfeeds.db**
- **内容**：交易流数据库
- **状态**：当前版本代码中未使用此功能
- **说明**：预留功能，暂未实现

**7. wallet.db**
- **内容**：存储本地钱包数据库
- **具体用途**：
  - 用户信息（User Information）
  - 资产详情（Asset Details）
  - 交易记录（Transaction Records）
  - UTXO 信息（UTXO Information）
  - 其他相关数据
- **作用**：管理本地钱包的所有数据

---

#### 6.5 数据存储位置

**默认存储位置：**
- 默认存储在 `--home` 参数下的 `data` 目录中
- 不同平台的默认路径：
  - **Darwin（macOS）**：`$HOME/Library/Bytom/data`
  - **Linux**：`$HOME/.bytom/data`
  - **Windows**：`%APPDATA%\Bytom\data`

**文件结构示例：**
```
data/
├── accesstoken.db
├── core.db
├── discover.db
├── trusthistory.db
├── txdb.db
├── txfeeds.db
└── wallet.db
```

---

#### 6.6 缓存机制

**工作流程：**
```
查询请求
    ↓
检查缓存（Cache）
    ↓
    ├─→ 缓存命中？
    │       ↓
    │   返回缓存数据
    │
    └─→ 缓存未命中？
            ↓
        从 LevelDB 读取
            ↓
        添加到缓存
            ↓
        返回数据
```

**优势：**
- 减少磁盘 I/O 操作
- 提高查询速度
- 降低系统负载

**缓存策略：**
- LRU（Least Recently Used）策略
- 定期清理过期缓存
- 缓存大小限制

---

#### 6.7 连接关系

- `Level DB` → P2P 分布式网络层（数据同步）
- ← 内核层（存储区块和交易）
- ← 钱包层（存储钱包数据）
- ← 共识层（存储共识相关数据）

---

#### 6.8 实现要点

**技术要点：**
- LevelDB 或 BoltDB 的选择和使用
- 缓存策略设计（LRU、LFU 等）
- 数据索引优化
- 批量写入优化
- 数据压缩

**设计要点：**
- 数据库文件分离（不同数据存储在不同文件）
- 缓存和持久化存储的协调
- 数据备份和恢复机制
- 数据迁移策略

---

### 7. P2P 分布式网络层（P2P Distributed Network Layer）

**组件：**
- `discover` - 节点发现机制
- `block sync` - 区块同步
- `tx sync` - 交易同步
- `fast broadcast` - 快速广播

**功能：**
- 实现去中心化的节点通信
- 节点发现和连接
- 区块和交易的同步
- 消息广播机制

**连接关系：**
- → 运行环境

**实现要点：**
- Kademlia DHT 算法（节点发现）
- 区块同步协议
- 交易广播协议
- 网络消息编码/解码

---

### 8. 运行环境（Runtime Environment）

**组件：**
- `宿主机`（Host Machine）
- `云机器`（Cloud Machine）
- `容器`（Container）

**功能：**
- 区块链节点的部署和运行环境
- 支持多种部署方式

---

## 🔄 数据流向分析

### 交易流程
```
用户交互层（bytomcli）
    ↓
接口层（API Server）
    ↓
内核层（交易管理：build → sign → submit）
    ↓
钱包层（密钥管理：签名）
    ↓
内核层（交易验证）
    ↓
共识层（PoW/Tensority）
    ↓
数据存储层（持久化）
    ↓
P2P网络层（广播）
```

### 区块流程
```
P2P网络层（接收区块）
    ↓
内核层（区块验证）
    ↓
共识层（PoW/Tensority）
    ↓
数据存储层（存储区块）
```

### 智能合约流程
```
用户交互层
    ↓
接口层（handler）
    ↓
内核层（智能合约：BVM执行）
    ↓
钱包层（资产管理）
    ↓
数据存储层（存储状态）
```

---

## 💻 代码实现

### 架构设计思路

#### 模块划分原则
1. **分层设计**：每层职责清晰，上层依赖下层
2. **模块化**：每个模块独立，便于开发和测试
3. **接口抽象**：层与层之间通过接口交互
4. **数据流向**：明确数据在各层之间的流转

#### 关键模块对应关系

| 架构层 | 代码模块 | 对应章节 |
|--------|---------|---------|
| 用户交互层 | `cmd/cli/` | 第二章 |
| 接口层 | `internal/api/` | 第四章 |
| 内核层-交易 | `internal/transaction/` | 第六章 |
| 内核层-区块 | `internal/block/`, `internal/blockchain/` | 第五章 |
| 内核层-智能合约 | `internal/contract/` | 第七章 |
| 内核层-虚拟机 | `internal/vm/` | 第八章 |
| 钱包层 | `internal/wallet/` | 第九章 |
| 共识层 | `internal/consensus/pow/`, `internal/consensus/pos/` | 第十二章、第十三章 |
| 数据存储层 | `internal/storage/` | 第十一章 |
| P2P网络层 | `internal/network/` | 第十章 |

#### 实现顺序建议
1. **第一阶段**：数据存储层 + 内核层（区块、交易）
2. **第二阶段**：共识层 + P2P网络层
3. **第三阶段**：钱包层 + 接口层
4. **第四阶段**：智能合约 + 用户交互层

---

## 📊 架构图总结

### 核心设计理念
1. **分层架构**：清晰的层次划分，便于维护和扩展
2. **模块化设计**：每个模块职责单一，高内聚低耦合
3. **数据驱动**：数据在各层之间有序流转
4. **可扩展性**：支持多种共识算法和部署方式

### 关键依赖关系
- **交易管理** 依赖 **密钥管理**（签名）
- **智能合约** 依赖 **资产管理**（资产操作）
- **交易/区块验证** 依赖 **共识层**（共识确认）
- **所有层** 依赖 **数据存储层**（持久化）
- **数据存储层** 依赖 **P2P网络层**（数据同步）

---

## ❓ 遇到的问题

1. **问题描述**：
   - 解决方案：
   - 参考资料：

---

## 📝 学习心得

### 架构理解要点
- [ ] 理解了7层架构的设计思路
- [ ] 理解了各层之间的依赖关系
- [ ] 理解了数据在各层之间的流转
- [ ] 理解了模块划分的原则

### 关键收获
- 分层架构使系统结构清晰，便于开发和维护
- 内核层是系统的核心，包含所有核心逻辑
- 数据存储层和P2P网络层是基础设施
- 钱包层和共识层是区块链的特色功能

---

## 🔗 相关资源

- 《Go 语言公链开发实战》第一章
- 比原链官方文档
- 比原链 GitHub 源码

---

## ✅ 学习检查清单

- [x] 理解比原链的7层架构
- [x] 理解各层的职责和组件
- [x] 理解数据流向和依赖关系
- [ ] 画出自己的架构图
- [ ] 总结各模块的作用和关系
